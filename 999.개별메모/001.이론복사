[ 자동스크롤 기능정의 ]
    1. 스크롤바가 없는 상태에서 마우스 휠 작동시
    아래와 같이 기능구현됨
    (1) 휠 내림 : 다음페이지로 이동
    (2) 휠 올림 : 이전페이지로 이동

    2. 스크롤바 첫페이지와 끝페이지에서 이동안함

[ 자동스크롤 이벤트 ]
    -> wheel 이벤트
    -> 마우스 휠 작동시 발생!
    (이전 이벤트명: mousewheel / DOMMouseScroll(파이어폭스))

[ 모바일 이벤트처리 ]
    
    [ 모바일 터치 스크린에서 사용하는 이벤트 종류 ]
    1. touchstart - 손가락이 화면에 닿을때 발생
    2. touchend - 손가락이 화면에서 떨어질때 발생
    3. touchmove - 손가락이 화면에 닿은채로 움직일때 발생
    
    [ 화면터치 이벤트관련 위치값 종류 ]
    1. screenX, screenY : 디바이스 화면을 기준한 x,y 좌표
    2. clientX, clientY : 브라우저 화면을 기준한 x,y 좌표(스크롤미포함)
    3. pageX, pageY : 스크롤을 포함한 브라우저 화면을 기준한 x,y 좌표

[ 드래그 기능 구현을 위한 이벤트 ]
1. 딸 -> 마우스 포인터 누름 -> mousedown

2. 각 -> 마우스 포인터 올라옴 -> mouseup

3. 질질 -> 마우스 움직일때 -> mousemove
-> 드래그 상태는 "딸"상태에서 "질질"하는것!

mousedown 할때 드래그 상태변수값을 1로 변경
mouseup 할때 드래그 상태변수값을 0으로 변경
_______________________________________

[ 드래그 기능구현 원리 ]

1. 마우스 포인터 위치에 따른 변화 수치를
계산하여 요소의 top,left 위치값으로 반영한다!

2. 프로세스
(1) mousedown 이벤트에서는 시작위치값 저장
- 모바일 이벤트 : touchstart
(2) mousemove 이벤트에서는 움직인위치와 시작위치 차이 저장
- 모바일 이벤트 : touchmove
(3) mousemove에서 차이값을 타겟요소의 left,top값에 반영
(4) mouseup 이벤트에서는 다음 이동을 위한 마지막위치 저장
- 모바일 이벤트 : touchend
(5) mousemove 이벤트에서 마지막위치로 부터의 이동을 계산함

[ 이벤트발생시 위치값 ]
    1. clientX, clientY
        -> 현재 보이는 브라우저 화면이 기준
        -> 화면을 기준한 fixed 포지션에서 주로 사용!
    2. offsetX, offsetY
        -> 이벤트 대상이 기준
        -> 특정박스가 부모자격박스로부터 위치를 사용 할 경우
    3. pageX, pageY
        -> 전체 문서를 기준(스크롤 화면을 포함)
        -> 화면을 기준한 absolute포지션에서 주로 사용!
    4. screenX, screenY
        -> 모니터 화면을 기준

[ 스크롤 이벤트를 활용한 요소 등장 액션 기능 구현하기 ]

 1. 사용 이벤트 :scroll
 -> 스크롤 바가 있는 페이지에서 또는 부분박스에서 사용 가능함
 -> **주의**: wheel이벤트와 다르다!
 스크롤 바가 이동하지 않아도 마우스 휠이 작동 될 때 발생
 휠 이벤트는 모바일에서 사용 불가

 2. 스크롤바 위치 값 알아내기
    1) window.scrollY (IE6~11지원안함)
    2) document.scrollingElement.scrollTop
    3) document.documentElement.scrollTop
    4) document.querySelector('html').scrollTop
    가로방향은 X대신Y

3. 스크롤 등장 대상 요소의 보이는 화면에서의 top값
    getBoundingClientRect().top
    -> 보이는 화면 상단을 기준으로 이것보다 위로 갈 경우 -값을 리턴
    -> 기준: 보이는 화면의 크기를 기준하면 됨
    -> 윈도우 화면 전체: window.innerHeight
    예) 화면의 2/3는 window.innerHeight/3*2 : 위에서부터 66%위치
    예) 화면의 3/4은 window.innerHeight/4*3 : 위에서부터 75%위치

[ 패럴렉스 기능 구현하기 ]

    1. 정의
    스크롤 작동 시 같은 방향으로 이동하는 요소가 
    다른 속도를 가지고 움직이므로 
    사용자가 공간감을 느낄 수 있게 하는 구현방법

    2. 방법
        (1) 범위 - 요소가 화면에 등장하여 
        보일 동안 스크롤 될 때 이동함
        (2) 움직일 크기 설정이 필요함
        (3) 범위 체크를 위한 js 메서드를 사용함
        -> getBoundingClientRect().top
    
    3. 이벤트 : scroll

    4. 패럴렉스 대상 : 특정클래스 지정 
        (1) 글자박스 대상 : .txt
        (2) 아이콘 이미지 대상 : .icon

[ 패럴렉스 위치 계산 ]
        
        1. 전체범위 : window.innerHeight
        2. 위치값 : getBoundingClientRect().top
        3. 정한범위 : 이동 할 수치 
        4. 실제이동값 : transform:translateY(이동수치px);
        ______________________________________________
        
        ((비례식으로 실제 이동값 알아내기))
        
        전체범위 : 위치값 = 정한범위 : 실제이동값
        실제 이동값 = 위치값*정한범위 / 전체범위

        -> 그.런.데...
        Y축 위치 이동은 처음에 0부터 서서히 커지므로
        이동수치값은 정한범위에서 실제 이동값을 빼야함

        실제 이동값 = 정한범위 - (위치값*정한범위 / 전체범위);

    **************************************/
    /*
    getBCR는 스크롤 내릴수록 작아짐 (요소가 움직이 범위에 대한 변수)
    getBCR는 숫자 작아짐 (화면높이부터~0으로)
    화면이동값 translateY(-스크롤Y(0부터 화면높이로 커짐));
    두 값의 비례식을 위해서 값의 조정이 필요함

    전체범위 : 위치값 = 정한범위 : (정한범위 - 실제이동값)
    */

<meta name="description" content="현재 사이트의 내용을 검색되도록 요약설명을 여기에 씀(사이트키워드)">
메타태그 keyword가 있지만 구글에서 실제 키워드검색으로 description을 사용

[ CSS 속성 셋팅 형식 ]
    선택자{
        속성:값;
    }
    [ 선택자의 종류 ]
    1. 타입선택자 : 태그명(div,p,a 등)
    2. 아이디선택자 : #아이디명
    3. 클래스선택자 : .클래스명
    4. 자손선택자 : 띄어쓰기(div a)
    5. 직계자식선택자 : 오른쪽꺽쇠(div>a)(바로 밑)
    6. 종속선택자 : 요소명#아이디명 || 요소명.클래스명
    (div.mymy -> div인데 클래스가 mymy , 띄어쓰면 자식이 됨)
    7. 형제선택자 : 요소+요소(a+a)
    (앞 요소가 있는 선택자를 사용, 즉 2번째부터 사용 됨)
    8. 그룹선택자 : 선택자,선택자(html,body,h1,h2)
    (여러요소를 동시에 선택)

vertical-align: 인라인요소간 세로정렬(세로위치조정)
    값 - top/bottom/middle/baseline/숫자

[ 선형 그라데이션 : linear-gradient ]
    
    background-image: linear-gradient(방향, 색1, 색2);
    background-image: linear-gradient(방향, 색1 몇%, 색2 몇%);
    background-image: linear-gradient(각도, 색1 몇%, 색2 몇%);
    - 옵션
        1.방향 : to top, to bottom, to left, to right
        2.각도 : 각도deg
        3.콤마로 나열된 색상에 %를 뒤에 쓰면 비율조정 가능
배경 옵션 추가
        background-clip : 배경이 적용되는 범위설정
        1. border-box -> 보더까지 적용(기본값)
        2. padding-box -> 패딩까지 적용
        3. content-box -> 내용영역만 적용(패딩, 보더 빠짐)

[ 1줄 말줄임표 처리 ]
1. 줄바꿈방지
white-space: nowrap;
2. 넘치는 컨텐츠 숨기기
overflow: hidden;
3. 넘치는 글자 말줄임표 처리
text-overflow: ellipsis;

[ 여러줄 말줄임표 ]

    display: -webkit-box;
    overflow: hidden;
    text-overflow: ellipsis;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical; 

    **주의 박스 높이값을 글자가 보일만큼 조절해야함
    **주의 white-space: nowrap이 없음
[ CSS 가상클래스 : 자식요소 종류가 같아야함! ]
    - 요소: nth-child(n) -> n번째 자식요소
    - 요소: first-child -> 첫번째 자식요소
    - 요소: last-child -> 마지막째 자식요소

    [ 여러종류가 섞여 있을 경우 형제 선택하기 ]
    - 요소: first-of-type -> 같은 요소 중 첫번째
    - 요소: nth-of-type(n) -> 같은 요소 중 n번째
    - 요소: last-of-type -> 같은 요소 중 마지막째

[ 테이블 가로크기 ]
테이블은 기본적으로 내용만큼의 가로크기를 가지며
    부모박스의 크기가 작아질 경우 그 크기에 맞춰진다
테이블 기본 간격 삭제 : 기본값은 seperate
border-collapse: collapse;

[ 웹 표준이란? ]
        - 모든 브라우저에서 하나의 소스로 동일한 디스플레이 및 기능이 작동하도록 정한 웹 코딩의 표준안
        [ 웹 접근성이란? ]
        - 평등의 원칙. 즉, 장애인 차별금지법에 따라 이미지(alt속성), 동영상(자막) 등의 설명을 추가하여
            정보제공의 차별이 없도록 함
        [ img요소 : 이미지 연결요소 ]
        - 필수속성
        1) src(source) : 이미지 경로
        2) alt(alternative text - 대체 텍스트) : 이미지 설명(웹 접근성)
        [ 레이아웃을 위한 블록요소 ] 
        태그는 개별적인 이름을 하나하나 지칭할 때 개별적인 요소명을 하나하나 모아서 만들 때
        요소는 공통적으로 묶어서 말할 때
        div : 영역을 나누고 묶어주는 요소
        [ HTML5에서 등장한 div친구들 ]
        - div에 내용을 구분하는 이름을 지어줌
        - 시멘틱 태그(의미를 부여)
        - 의미가 있는 요소를 시멘틱이라고 함!
            1. header : 머릿부분
            2. footer : 하단부분
            3. main : 메인부분(한 페이지당 1번)
            4. nav : 네비게이션 부분
            5. aside : 부가정보
            6. section : 내용구분파트
            7. article : 독립된 내용구분파트
            (section / article 내부에 h1~h6태그를 쓸 것을 권고함)
        참고) 요소와 태그는 무엇이 다른가?
        요소(element)는 공통적인 성질을 이를 때 사용
        태그(tag)는 구체적인 요소를 사용할 때 지칭하는 말
        [ 웹에서의 경로 ]
        1. 상대경로: 현재파일 위치에서 파악되는 경로
            ./ : 현재위치(또는 생략)
            ../ : 상위폴더 이동
            ../../ : 상위폴더의 상위폴더로 이동
        2. 절대경로: http부터 쓰는 웹 경로
        3. 절대상대경로: 웹 사이트 루트부터의 경로
            (/)부터 씀
            ***주의: 절대상대경로는 서버 루트폴더가 같지 않으면 경로가 망가짐.
                    또는 로컬에서 직접 웹페이지를 열어도 망가진다.(루트가 달라서)
        [ figure 요소 :HTML5에서 새로 등장한 요소(도형,인물) ]
    - 이미지나 표를 포함하는 박스요소
    - block box요소
    - 이미지 설명은 내부 요소인 figcaption을 사용함
    (설명이 있을 경우에만 사용)
        [ iframe 요소 ]
        - inline frame
        - 한 웹 페이지 안에 다른 시스템의 웹을 불러올 수 있는 요소
        - 필수속성 : src - 시스템경로
        **주의: CSS설정으로 디자인을 변경하자
        ex)width height frameborder 속성 쓰지말자
        [ p 요소 : 문단(paragraph) ]
        - 문단을 구분하기위한 요소
        - **주의: 내부에 div와 같은 block요소를 넣을 수 없다.
        [ HTML 요소에서 특수문자 처리 ]
        & 엠퍼센드  &amp;(Ampersand)
        < 여는 꺽쇠 &lt; (less than ~보다 작은)
        > 닫는 꺽쇠 &gt; (greater than ~보다 큰) 
        [ 순서없는 리스트 : ul ]
        unordered list 
        (참고: 블릿옵션
        https://www.w3schools.com/tags/tryit.asp?filename=tryhtml_ul_type_css)

        [ 순서있는 리스트 : ol ]
        ordered list
        (참고: 순서표시옵션
        https://www.w3schools.com/tags/tryit.asp?filename=tryhtml_ol_type_all_css)
        - start 속성 : 시작번호
        - reverse 속성 : 일련번호를 거꾸로 진행

        [ul/ol 공통사항]
        - 하위필수요소: li (개별리스트)
        - 주의: 하위에 li이외의 블록요소나 그 어떤요소도
        쓸 수 없다!!! 

        [ 용어정의리스트 : dl ]
        
        dl > dt + dd
        ________________________________________

        dl : 용어리스트
        (defines the description list)
        dt : 용어정의
        (defines the term)
        dd : 용어설명
        (description each term)
        ________________________________________

        **주의 - dl은 반드시 자식요소로 dt와 dd를
        한번이상 사용해야한다!
        **또주의 - dt와 dd는 형제다! dt>dd 아니다!!!

    [ 1. HTML 서식관련 요소들 ]
    1. 두꺼운 글자
    <b>- 굵은 텍스트(Bold text - 단순 글자만 두꺼움)
    <strong>- 중요 텍스트(Important text - 중요함의 의미)
    
    2. 이텔릭 글자 (용어, 외국어, 생각등)
    <i>- 기울임꼴 텍스트(Italic text - 단순 글자만 이텔릭처리)
    <em>- 강조된 텍스트(Emphasized text - 강조의 의미)
    
    3. 색상표시
    <mark>- 표시된 텍스트(Marked text - 눈에 띄게 표시)
    
    4. 작은 글자
    <small>- 더 작은 텍스트(smaller text)
        - h5 요소의 글자크기와 같음
        - 상속 된 글자 크기에 대한 상대적인 크기이므로 
            브라우저에서 소수점으로 표시될 수 있음
    
    5. 삭제된 글자
    <del>- 삭제된 텍스트(Deleted text)
        - text-decoration: line-through

    6. 삽입된 글자
    <ins>- 삽입된 텍스트(Inserted text)
        - text-decoration: underline
    
    7. 첨자 표시
    <sub>- 아래 첨자 텍스트(Subscript text)
        - 약간 아래쪽 작은 글자
        - 병행표시글자(영문, 한문 등)
    <sup>- 위첨자 텍스트(Superscript text)
        - 약간 윗쪽 작은 글자
        - 주석표시숫자(숫자와 설명을 연결)
        ____________________

        [ 시멘틱 태그란? ]
        - sementic(의미론적인, 의미있는)
        즉, 태그가 어떤 구분하는 의미가 있을 경우
        이런 요소를 시멘틱 태그라고 부른다
        예)strong, em, address, header, footer 등

        - 시멘틱 태그를 쓸 때 장점은?
        1) 정보에 대한 의미있는 별도의 컨트롤이 가능함
        2) DB서버에서 데이터 수집 및 분석 시에 활용하여 더 정교한 데이터 검색이 되도록 함
            (DB 데이터 크롤링에 활용)

    [ 2. 인용 관련 요소들 ]
    1. 블록 인용 요소
    <blockquote>
        - 별도의 인용구를 구분하는 박스
        ** 주의 : 내부에 p요소와 같은 다른 블록요소 사용 불가
        - cite 속성 : 출처표시
        (필수 속성은 아님
            url 주소가 들어가서 링크로 오해할 수 있으나 단순출처임)
    2. 인라인 인용 요소
    <q>
        - 작은 인용구(quotation : 쌍따옴표가 자동생성됨)
        ** 주의 : 인라인요소임(blockquote와 구분 할 것)
    3. 줄임말 인용
    <abbr>
        - 줄임말의 원래 뜻을 표시하는 요소(abbreviation)
        - 필수속성 : title 속성, 툴팁으로 원래 뜻을 표시
        ※참고 : title 툴팁속성은 어느 요소든 사용 가능함!
        - 기본디자인 : 점선
    4. 주소인용
    <address>
        - 주소, 대표자, 전화번호 등 사이트 정보표시의 의미
    5. 작품명 인용
    <cite>
        - 인용하고 있는 작품을 표시하기 위한 요소
    6. 텍스트 반대방향글 인용
    <bdo>
        - 글 방향이 반대일 때 사용함
        - Bi-Directional Override(줄임말)
        - dir 속성 : rtl(right-to-left 오른쪽에서 왼쪽으로 진행)
        - 아랍어, 이스라엘어 등 반대방향으로 출력해야 하는 문자를 이용할 때 사용함!

    [ 테이블 요소 기본 특성 ]
    1. 다른 요소가 옆에 못오는 block요소적 성질이 있음
    2. 가로크기는 내용 만큼만 늘어남
    3. 자신을 싸고 있는 박스가 내용보다 작아지면 
        가로스크롤이 생기지 않도록 내용을 랩핑하여 
        줄바꿈처리
        (단, 이미지와같이 크기고정요소가 있으면 가로스크롤 생성)
    테이블은 max-width를 특정 px로 주면 table이 적용안됨!
    td 셀 사이 간격
        border-spacing: 가로 세로;
        border-spacing: 양방향

    전체 배경넣기 - 가상요소로 배경고정을 대신함
    ios에서 background fixed지원안함
body::before{
    content: '';
    position: fixed; /* 블록처럼 됨 */
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: -1;
    /* min-height: 100vh; 있어도 없어도 같음. 컨텐츠가 많아져서 */
    background: url(../ab_img/space.jpg) no-repeat center/cover;
}
html{
    /* 부드러운 스크롤 */
    scroll-behavior: smooth;
}

[ object-fit 속성 ]
    -> img, video 요쇼에 사용하는 맞춤속성

    - 부모요소 크기를 채우는 방식을 결정함!
    - contain 기본값
    - 특히 이미지일 경우 배경이미지로 넣어야
    빈공간 없이 비율을 유지하면 채울 수 있다고
    생각하는데 이 속성을 사용하면 마치 배경이미지처럼
    이미지를 채우고 나가는 부분을 처리함

    1. cover : 이미지나 동영상 비율유지하며
                부모박스를 빈공간 없이 채움
                (잘리는 부분이 있을 수 있음)
    2. fill : 이미지나 동영상의 비율을 깨고
                부모박스를 빈공간 없이 채움
                (잘리는 부분이 없다)
    3. contain : 이미지나 동영상이 모두 보이며
                비율을 유지함
                (잘리는 부분이 없으나 빈 공간 생김)

[ object-position 속성 ]
- object-fit을 사용한 설정에서 위치를 이동할때 사용
- 이미지나 동영상의 기준값을 변경 적용할 수 있다!
- 설정법:
    object-position : 가로값 세로값;
    1) 가로값 - left, center, right, 수치(px,% 등)
    2) 세로값 - top, center, bottom, 수치(px,% 등)
    -> 기본값은 가로값,세로값 모두 center임!

[ CSS 애니메이션 ]
    - CSS 속성 변화를 장면으로 구성하여
    애니메이션을 화면에 연출해주는 속성

    [ 애니메이션 키프레임 ]
    - 애니메이션 속성 변화를 지정하는 코딩영역

    [ 2장면 코딩법 ]
    
    @keyframes 키프레임명 {
        from{시작CSS}
        to{끝CSS}
    }
    또는
    @keyframes 키프레임명 {
        0%{시작CSS}
        100%{끝CSS}
    }

    [ 여러장면 코딩법 ]

    @keyframes 키프레임명 {
        0%{시작CSS}
        10%{중간CSS}
        20%{중간CSS}
        ...
        70%{중간CSS}
        90%{중간CSS}
        100%{끝CSS}
    }

    -> 만약 첫 장면이 이미 CSS에 설정되어 있으면
    from 또는 0%를 생략할 수 있다.
    _________________________________________

    [ 애니메이션 연출 시간 계산법 ]

    - 내가 지정한 %의 장면은 언제 등장하는가?

    전체시간(s) * 몇% / 100 = 알고싶은 시간
    ex) 60s * 50/100 = 30초
    _________________________________________

    [ 설정 된 키 프레임 호출하는 방법 ]

    animation : 이시이지반방마
    (이름 시간 이징 지연 반복 방향 마지막상태)

    1) 이름(animation-name) : keyframe 이름
    2) 시간(animation-duration) : 애니메이션 동작시간(초단위:s)
    3) 이징(animation-timing-function) : easing 가속도
    4) 지연(animation-delay) : 애니메이션 시작지연시간(초단위:s)
    5) 반복여부(animation-iteration-count) : 애니메이션 반복횟수
        - 기본값 1, 숫자를 쓰면 반복횟수
        - 영원히는 infinite(인피니트)
    6) 방향(animation-direction) : 시작->끝
        - 대체경로 설정하기 : alternate : 시작->끝,끝->시작
        - 대체경로는 반복횟수가 2이상 또는 infinite 이여야함
    7) 마지막상태(animation-fill-mode) : 애니메이션이 끝났을때
        - 처음상태로 돌아가는 것이 기본! backwards
        - 마지막 상태를 유지하고 싶을때 forwards(앞쪽에...즉,애니끝장면)

    첫번째 자식요소 블록박스에 마진탑을 준 경우 그 마진값은 
    부모요소 바깥쪽으로 나간다!(기본성질)
    마진탑을 포함하려면 부모요소에 overflow:hidden을 설정해야함
    +하단 마진도 부모 요소 밖으로 나감


 [ 1. 선형그라데이션 ]

    1) 균등분할 그라데이션
    background-image: 
        linear-gradient(방향, 색1,색2,색3,...);
    - 방향: to top, to bottom, to right, to left

    2) 사용자 지정영역 그라데이션
    background-image: 
        linear-gradient(방향, 색1 몇%,색2 몇%,색3 몇%,...);
    - 색상 뒤에 한칸 띄어 %수치를 주면 색상영역조정됨

    3) 각도 지정 그라데이션
    background-image: 
        linear-gradient(각도, 색1,색2,색3,...);
    - 각도: 각도수치deg

    _____________________________________________

    [ 2. 원형 그라데이션 ]

    - 기본형, 영역지정형은 박스모양을 따라감!

    1) 기본형: 중앙중심, 모양은 박스크기에 맞춤
    background-image: 
        radial-gradient(색1,색2,색3,...);
    - 시작색으로부터 중앙에서 시작됨

    2) 영역 지정형:
    background-image: 
        radial-gradient(색1 몇%,색2 몇%,색3 몇%,...);
    - 색 뒤에 한칸 띄고 %수치로 영역지정함

    3) 그라데이션 모양을 원형으로 사용할 경우:
    background-image: 
        radial-gradient(circle,색1,색2,색3,...);
    - circle 키워드를 첫번째에 사용함

    4) 영역옵션 지정형: 중심점 변경
    background-image: 
        radial-gradient(옵션 at 가로위치 세로위치,색1,색2,색3,...);
    - 옵션4가지 : closest-side / farthest-side
                closest-corner / farthest-corner
                ___________________________________
                - closest는 중심점으로 좀더 모아진것
                - farthest는 중심점에서 멀리 퍼진것
                - side와 corner는 경계선과 끝부분옵션임
    - 가로위치, 세로위치 (중심점) - 단위는 px / %

    [ 다단설정하기 ]
    - 다중 열속성
    -> column-count : 다중열개수
    -> column-rule : 다중열구분선
    -> column-gap : 다중열사이간격

    window.addEventListener('wheel',(e)=>{
    // 기본기능 막기(휠, 우클릭 등등!)
    e.preventDefault();
    // 이벤트 호출 확인
    console.log('휠~',e.wheelDelta);
    // 휠 방향 분기
    // 페이지 이동확인
    window.scrollTo(0,window.innerHeight*(e.wheelDelta<0?1:0));
    // window.scrollTo(x스크롤 위치값, y스크롤 위치값);
    // window.innerHeight*(e.wheelDelta<0?1:0)
    // 윈도우 높이값*음수면 1곱하기 양수면 0 곱함 (페이지가 늘면 페이지만큼 추가)
    // 아래방향은 윈도우 높이 / 윗 방향은 위치값 0

    // 두번째 페이지일 때 동영상 플레이 하기
    if(e.wheelDelta < 0){
        // qs('.trailer-box iframe').setAttribute('src','https://www.youtube.com/embed/Ko2NWhXI9e8?autoplay=1');
        qs('.trailer-box iframe').src = 'https://www.youtube.com/embed/Ko2NWhXI9e8?autoplay=1';
    }else{
        qs('.trailer-box iframe').src = 'https://www.youtube.com/embed/Ko2NWhXI9e8';
        // qs('.trailer-box iframe').setAttribute('src','https://www.youtube.com/embed/Ko2NWhXI9e8');
    } //////////////if/////////////////
    
},{passive:false});

// 주의 : 유튜브 박스 내부는 다른 공간이라 휠막기가 안됨
// 이벤트는 위로 전달 되므로 (이벤트 버블링) 이를 막아준다!
// 막는 방법 : 그만해!stop! 전파를!propagation! event.stopPropagation() 메서드 활용

[ 객체를 위한 for in 문 ]

   - 구문: 
   for(변수 in 객체){코드}

   - 작동원리:
   객체의 개수만큼 순서대로 속성명과 속성값을 가져옴

   - 변수는 객체의 속성명이다!

   - 객체의 값을 사용하려면 for in 문 안에
       객체[변수] 로 쓰면됨!

[ for of 문 ]
    ___________________________

    - 일반for문에 비해 간단한 형식의 for문
    ((형식))
    for(변수 of 배열/컬렉션){실행문}

    ((특징))
    -> 시;한;증 이 필요없다!
    -> 배열/컬렉션 개수만큼 알아서 돌아줌!
    -> ES6에서 새롭게 등장함!

    -> 부가기능: 
    문자데이터를 넣으면 한글자씩 돌아줌! 
    for(변수 of 문자데이터변수) {실행문}
    -> 한글자씩 태그로 싸줄때 편리함!

[ 배열과 컬렉션을 위한 forEach() ]
    forEach()는 
    배열과 컬렉션을 위한 JS메서드임!
    -> ES5에서 새롭게 등장!(배열메서드!)

    1. 컬렉션에 사용시

    컬렉션.forEach(
        function(ele,idx,obj){코드})
    ________________________________

    컬렉션.forEach(
        (ele,idx,obj) => {코드})

    _______
    전달변수
    1) ele -> 첫번째 전달변수 : 요소자신
    2) idx -> 두번째 전달변수 : 순번
    3) obj -> 세번째 전달변수 : 전체컬렉션

    *****************************

    2. 배열에 사용시

    배열.forEach(
        function(val,idx,obj){코드})
    ________________________________

    배열.forEach(
        (val,idx,obj) => {코드})

    _______
    전달변수
    1) val -> 첫번째 전달변수 : 배열값
    2) idx -> 두번째 전달변수 : 순번
    3) obj -> 세번째 전달변수 : 전체배열

    ========================

    공통사항)
    - 전달변수의 순서와 개수가 중요함
    - 전달변수명은 어떻게 지어도 무관
    - 값이나 요소만 쓰려면 변수를 하나만씀
    - 순번까지 쓰려면 변수를 두개씀
    -> 보통 변수를 2개까지 많이 씀
    - 명령어를 사용하여 로직을 수행하는 것은
    함수 중괄호안에 코딩하면 된다!

[ 화면으로부터 좌표값 찍기x,y ]
    발생이벤트의 pageX,pageY
    event.pageX/event.pageY
    전달변수 하나쓰고 ex)e
    내부에 e.pageX / e.pageY로 사용!
    (1).pageX : 화면 왼쪽 끝에서부터 px위치
    (2).pageY : 화면 위쪽 끝에서부터 px위치
    screenX, screenY (보이는 화면기준)
[ 마우스포인터 이벤트 속성 ]
    pointer-events: auto;
    -> 기본값 : 대상 요소에 이벤트 발생
    pointer-events: none;
    -> 대상 요소의 이벤트 무시
    -> 대상 요소의 아래쪽 요소에 이벤트 발생

<!-- 파비콘 : 탭메뉴 출력 아이콘 -->
<link rel="shortcut icon" type="image/x-icon" href="./images/robot_03.png">

[ Transform 효과주기 ]
        - 선택요소의 크기, 회전, 이동, 기울임
            등 변형을 하기위한 속성
        - 2D, 3D 지원됨

        1. rotateY(각도deg) - Y축회전
        - deg 는 각도의 단위(도:degree)
/* CSS 필터적용하기 
        : 필터속성은 흑백, 흐림, 세피아, 명암,
        채도 등 출력 이미지를 변경하고자 할때
        사용하는 속성
        (참고) 
        https://www.w3schools.com/cssref/playit.php?filename=playcss_filter&preval=blur(5px)*/
[ Transform 효과주기 ]
        - 선택요소의 크기, 회전, 이동, 기울임
            등 변형을 하기위한 속성
        - 2D, 3D 지원됨

        1. rotateY(각도deg) - Y축회전
        - deg 는 각도의 단위(도:degree)
/* CSS 필터적용하기 
        : 필터속성은 흑백, 흐림, 세피아, 명암,
        채도 등 출력 이미지를 변경하고자 할때
        사용하는 속성
        (참고) 
        https://www.w3schools.com/cssref/playit.php?filename=playcss_filter&preval=blur(5px)*/
2. rotateX(각도deg) - X축회전
        - deg 는 각도의 단위(도:degree)
3. translateX(거리) - X축이동
        - 단위 : px, % 등
        - 현재 위치로부터 이동
        - 기준점은 요소의 왼쪽
        - % 단위를 쓸경우 기준은 요소의 width값
        - 이동방향: + 오른쪽, -는 왼쪽
4. translateY(거리) - Y축이동
        - 단위 : px, % 등
        - 현재 위치로부터 이동
        - 기준점은 요소의 윗쪽
        - % 단위를 쓸경우 기준은 요소의 height값
        - 이동방향: + 아랫쪽, -는 윗쪽
5. translate(x축거리,y축거리) - X,Y축이동
        - 단위 : px, % 등
        - 현재 위치로부터 이동
        - 기준점은 요소의 윗쪽, 왼쪽선
        - % 단위를 쓸경우 기준은 요소의 
            width,height값
        - 이동방향: + 오른쪽/아랫쪽, -는 왼쪽/윗쪽
6. rotate(각도deg) - 원형회전
        - 각도의 숫자가 양수이면 시계방향
        음수는 반시계방향
        - 기본회전축은 정중앙
        (변경가능: transform-origin)
transition: 속시이지
        개별 설정이 가능함!
        1. 속성 : 
            transition-property
        2. 시간 :
            transition-duration
        3. 이징(가속도) :  
            transition-timing-function
        4. 지연시간 :
            transition-delay
[ 트랜스폼 회전축 변경속성 ]
        transform-origin: 가로 세로;
        - 가로값 : left, right, center, 몇px,몇%
        - 세로값 : top, bottom, center, 몇px,몇%
        - 기본값 : 가로, 세로 center임! */
7. skew - x,y축 기울임
        - skewX(각도deg), skewY(각도deg)
        - skew(x축,y축)
        - 각도가 양수/음수에 따라 기울임 방향이 달라짐
8. scale(x축배수, y축배수)
        - 값을 하나만쓰면 양방향 같은 값 셋팅
        - 배수가 1보다 크면 확대, 작으면 축소
        - scaleX(배수), scaleY(배수) - x,y별셋팅
        - 값이 0이면 사라짐
        -> 가끔 크기가 정해진 요소를 일정크기로
        축소, 확대해서 크기를 맞출때도 용이함!
10. 앞뒤로 있는 이미지 뒤집기
        - 셋팅: 한 박스 안에 이미지가 2장 있고 이것을
        겹치게 셋팅한다-> 앱솔루트로 셋팅!
        - 순서는 나중 것이 위에 온다!
        - 적절한 트랜스폼, 트랜지션을 이용한다!

[ 동전 뒤집기 ]
* 1. 보거미 원본 */
    #trans10 img:last-child{
        /* 0도 회전하기 */
        transform: rotateY(0deg); /* 안써도 초기값 0deg */
        /* 트랜지션: 속시이지 - 0.4초기다림 */
        transition: .4s ease-out .4s;
        /* ease-out 나중에 천천히 처음엔 등속도 */
    }
    /* 2. 보거미 오버시 */
    #trans10:hover img:last-child{
        /* 90도 회전하기 */
        transform: rotateY(90deg);
        /* 트랜지션: 속시이지 - 기다림없음 */
        transition: .4s ease-in;
        /* ease-in 처음에 천천히 나중엔 등속도 */
    }
    /* 3. 유정이 원본 */
    #trans10 img:first-child{
        /* 90도 회전하기(처음상태) */
        transform: rotateY(90deg);
        /* 트랜지션: 속시이지 - 기다림없음 */
        transition: .4s ease-in;
        /* ease-in 처음에 천천히 나중엔 등속도 */
    }
    /* 4. 유정이 오버시 */
    #trans10:hover img:first-child{
        /* 0도 회전하기 */
        transform: rotateY(0deg);
        /* 트랜지션: 속시이지 - 0.4초기다림 */
        transition: .4s ease-out .4s;
        /* ease-out 나중에 천천히 처음엔 등속도 */
    }
        [ alsolute / fixed 포지션에서 정 중앙으로 보내기 ]
        1. calc로 계산하기 : 박스크기의 절반 빼기
        (1) top: calc(50% - 높이px/2);
        (2) left: calc(50% - 너비px/2);
        2. transform으로 중앙이동
        (1) top: 50%; / left: 50%;
        (2) tranform: translate(-50%,-50%);
        */
        /* 1. calc로 계산 */
        /* top: calc(50% - 334px/2);
        left: calc(50% - 334px/2); */

[ 배열데이터를 변경하여 다시 배열로 만들기 : map()]
    
  배열변수.map((배열값,순번,전체배열)=>{변경코드})
  -> 결과로 변경 된 배열이 리턴 됨

  ex) const arr = ['두현','대희','민희'];
  let arr2 = aa.map(val => val+'씨');
  -> 결과: ['두현씨','대희씨','민희씨'];
  ____________________________________________
  Array.isArray(배열); 
  -> 결과로 true / false가 리턴됨
  ____________________________________________
  -> 새로 만들어진 배열 데이터를 현재 자리에 그대로 출력할 때
  배열메서드 .join(구분자)를 이용하여 배열을 하나의 문자형
  데이터로 만들어 주면 편리하다.
  ex) const aa = ['하하','호호'];
  `<div>${aa.map(val => `<h2>${val}</h2>`).join('')}</div>`
  -> 결과: <div><h2>하하</h2><h2>호호</h2></div>
  -> 구분자가 없는 태그로만 구성 된 최종데이터를 그 자리에 출력 함
  ->>>>잊지말자 맵 조인

스크롤바 디자인 클래스 */
/* -webkit- 밴더사명(크롬,사파리) 접두어 
( 참고: -ms-(ie), -o-(오페라), -moz-(파이어폭스) */
.scbar::-webkit-scrollbar{
    /* 전체 스크롤바 크기변경 */
    width: 7px;
}
.scbar::-webkit-scrollbar-thumb{
    /* 스크롤바 */
    background-color: #555;
    border-radius: 5px;
}
.scbar::-webkit-scrollbar-track{
    /* 스크롤바 트랙 */
    background-color: #ddd;
    border-radius: 5px;
}
/* 배경이미지 설명클래스 (Image Replacement) */
.ir{
    display: block;
    width: 0;
    height: 0;
    overflow: hidden;
}
/* 이미지 관련 */
img{
    border: none;
    /* 이미지 링크시 기본보더 없앰
    - 서버 배포시에 나올 수 있음! */

    vertical-align: top;
    /* 인라인요소간 세로정렬속성을 셋팅한이유는?
        -> 박스요소안에 이미지가 단독으로 들어간
        경우 하단에 4px공백이 생김. 이때 이것을
        없애기 위해 vaertical-align속성을
        top/middle/bottom 이런 값을 사용하면
        공백이 없어진다!(단, 블록박스의 높이값은
        auto 이며 이미지에 의해 블록박스의 높이가
        결정되는 경우에 한한다!)
    */
}
// 2. 이벤트 지정 : timeupdate -> 동영상이 재생중 발생 이벤트
myvid.addEventListener('timeupdate',()=>{
    //  1. 동영상 멈춤여부 알아내기 함수
    // 비디오요소.paused => 멈추면 true
    let isStop = myvid.paused;
    console.log('동영상 재생 중~',isStop);
    // 2. 멈췄으면 페이지 이동
    if(isStop){
        location.href = 'main.html';
    }
}); ///////////timeupdate함수////////////////////

[ video 요소 - html5에서 지원하는 비디오 재생요소 ]

    -> img 태그와 비슷하게 쉽게 비디오를 삽입하도록 등장!

    ((속성들))
    1. src : 파일경로
    2. controls : 동영상 제어버튼바
        (이게 있으면 화면클릭으로 또는 스페이스바로 재생/멈춤 가능)
    3. autoplay : 자동재생(소리없음에서 작동)
    4. muted : 소리없음
    5. loop : 무한반복재생
    6. playsinline : 모바일 ios (아이폰) 동영상 재생시 자동재생 및 동영상이 페이지에 삽입된 상태에서 재생되도록 설정하는 옵션
    (안드로이드는 없어도 자동재생 및 삽입재생됨!) 
    7. poster : 비디오가 멈춤상태일때 첫화면 이미지
        (값으로 이미지 경로만 쓰면 됨) 
    _____________________________________________

    [ video 요소의 다른 표현법 ]
    - video 하위 source 요소를 사용한 표현법
    -> 이런 형식을 쓰는 이유는 같은 비디오가 브라우저에서
    지원되는 비디오 형식을 맞추는데 그 목적이 있다!
    -> 모든 비디오 형식을 지원하지 않을 경우
    source요소 맨 하단의 쓴 글자가 화면에 출력된다!
    
    예시코드)

    <video autoplay muted loop>
        <source src="images/cgv.mp4" type="video/mp4">
        <source src="images/cgv.ogg" type="video/ogg">
        <source src="images/cgv.webm" type="video/webm">
        당신의 브라우저는 본 비디오를 재생할 수 없습니다!
    </video>
 _________________________________________________

    [ 비디오 압축형식 ]
    1. mp4 - 최신 브라우저에서 지원하는 가장 보편적인
        비디오 압축형식(오디오 전용은 mp3)        
    2. ogg - 오픈 표준파일 형식 Xiph.org 재단에서 개발
    3. webm - 개방형 미디어 컨테이너. 높은 비디오 재생품질

    -> mkv, mov, avi 등과 같이 기존에 사용하던 일반
    압축형식은 브라우저에서 지원하지 않는 경우가 많다.
    따라서 비디오를 mp4형식으로 변환하여 올리게 좋다!
    (유튜브 동영상은 모두 mp4로 변환하여 서비스중이다!)

[ 구글맵 소스 가져오기 ]
    1. 구글맵 사이트로 이동하여 원하는 위치를
    검색한다.(https://www.google.com/maps)
    2. 왼쪽 햄버거 버튼을 클릭하여
    "지도공유 또는 퍼가기"메뉴를 클릭한다.
    3. "공유"별창의 "지도퍼가기"탭을 선택후
    HTML복사 버튼을 클릭하여 소스를 카피한다.
    4. 자신의 지도넣을 요소의 내부에 붙여넣기한다.

[ 스프라이츠를 이용한 장면 넘기기 애니를 하려면? ]
    1. 배경이미지 전체 길이를 알아야함
    -> 이유: 이동셋팅시 가로이동일 경우에 전체길이값을 써야함!

    (비율이 유지되는 이미지이므로 가로/세로중 한쪽값을 변경하면
    다른쪽값은 자동으로 변경된다!)

    참고) 비례식사용
        가로 : 세로 = 1472px : 325px = x : 176px
        x = 1472*176/325 = 797.14
        전체가 8장면 이므로 한 장면당 100px(99.625px)로 정해짐
    
    -> 더 편한 방법은 그림판에서 축소/확대를 사용하여
    길이를 알아내면 된다!    
    
    2. 코딩법:

    animation: 이름 시간 steps(장면개수) infinite;

    -> 장면찍는 steps를 사용할때는 이징(가속도)불필요!

    [ 여러줄 애니메이션 처리법 ]
    배경이미지 이동을 x,y축으로 분리하여 셋팅함

    -> 시간설정은 x축은 적당히 설정후
    y축은 x축애니시간*줄수 로 설정한다!

    예) x축 애니를 2초로 설정후 y축은 5줄이면 
    -> 2초*5줄=10초

    1. x축이동 : steps(장면수)
        background-position-x : 값;

    2. y축이동 : steps(줄수)
        background-position-y : 값;

[ z-index 사용의 일반용법 ]
1. z-index는 static이 아닌 포지션에 적용된다!
2. z-index는 부모요소에 설정되지 않은 경우
    자식요소급에 설정된 요소와 비교한다!
3. z-index는 부모요소에 설정된 경우 자식요소의
    z-index를 높여도 부모급요소보다 올라갈 수 없다!

(참고 : JS에서 이름짓는 일반규칙)
    1. 변수/함수 : 캐멀케이스(timeSlide)
    2. 생성자함수/클래스명 : 파스칼케이스(TimeSlide)
    3. 상수 : 모든글자대문자 및 스네이크케이스(TIME_SLIDE) 

[ 페이드 효과 슬라이드 기능정의 ]
    -> 슬라이드 순번에 대한 전역변수를 사용한다!

    1. 오른쪽 버튼클릭시 다음 순번슬라이드에
    클래스 "on"을 줘서 opacity:1, z-index:1
    로 보이며 맨위로 설정해준다!(트랜지션적용)
    ->나머지 li는 모두 "on"을 지워서 초기화!

    2. 왼쪽버튼은 이전순번이 나오며 위와 동일

    3. 끝번호에 가서는 처음은 마지막으로 
    마지막은 처음으로 슬라이드가 다시 반복된다.

    4. 블릿은 현재 슬라이드와 일치된 순번표시
[input 요소의 주요 속성들]

    1. name 속성: form태그의 내부 구성요소로 접근하는 접근경로를
    제공해주는 속성
    ex) form이름.name명

    2. placeholder 속성: 입력태그를 안내하는 문구를 초기에 출력해 주는
        속성(포커스가 가면 지워지거나 글자를 쓰면 지워진다-브라우저따라)
    
    3. maxlength 속성: 최대입력글자수 지정속성
    (단, 영어와 같은 1byte문자는 개수와 같으나 한글과 같은 2byte문자는
    절반의 개수만 들어간다.)

    ((4번~7번:html5에 새로추가된 속성내용))

    4. required 속성: 필수입력항목설정 속성(지정하면 html5 유효성 검사에서 안썼을 경우 필수여부를 화면에 표시함)

    5. autofocus 속성: 처음 로딩시 포커스가 가서 깜박이는 입력상태를 만들어주는 속성 (하나만 쓸것!)

    6. type 속성값 새로추가!(html5에서)
        - text의 세분화!!
        1) email : 이메일 형식
        2) date : 날짜 형식(달력도 제공함!)
        3) tel : 전화번호 형식
        4) url : 웹사이트 주소 형식
        - 기타 다양한 type의 값이 추가되어 있음!
        - 추가된 type의 값의 형식에 맞게 유효성검사를 할 수 있다!!!
        
    7. pattern 속성 : 각 입력양식의 값을 검사해주는 속성
                    내용으로 정규표현식을 써준다.
                    (각 pattern의 정규식은 인터넷에서 검색해라!)
        - w3schools.com 에서 우선 찾으시오!

    <input type="date" name="birth" id="birth" placeholder="YYYY-MM-DD" maxlength="10"
    min="2000-01-01" max="2010-12-31" required>
        max, min 속성 : type이 date인 경우 
        최대,최소입력값의 범위를 지정할 수 있는 속성
        - 범위를 지정한 경우 달력도 범위를 넘어가지 않게 제공됨!

    [ 젠코딩(에밋코딩) ]
    .bx#s${s$}*3
    __________________
    . : class
    # : id
    $ : 증가숫자
    *n : 반복생성횟수
    {} : 데이터출력
    [] : 속성세팅값
    > : 하위직계자식요소
    + : 형제요소
    () : 요소구분하기


    [ 2. relative 포지션 ]
    -렐러티브!
    1. 위치이동 속성이 적용된다
    2. 위치이동의 기준은 원래 있던 위치
        (그래서 상대적인 위치)
    3. 이동시 다른 요소에 영향이 없이 겹쳐질 수 있다.
    4. 원래 있던 위치는 그대로 보존된다.
        (기존 위치가 보존되기 때문에 본래의 디자인이 망가지지 않는다.)
    5. 위치값 설정시 2가지 기준으로만 셋팅한다
    - 위, 아래 중 하나
    - 좌, 우 중 하나
    top, left / bottom, right
    top, right / bottom, left
    box기준으로 안쪽이 + 밖이 -

    6. 마진은 그대로 적용된다!
    (다른 static한 요소에 영향을 미친다)
    -> 본래 위치에 마진이 적용 된 것이므로
    상대적인 이동값도 변경 된 것으로 보인다!

    7. relative는 위치 이동값을 사용하지 않으면
    static과 똑같은 특징을 가진다

    8. relative는 겹쳐질 수 있으므로
    위 아래 관계가 성립됨(z index)
    (1) static보다는 항상 위
    (2) static이 아니면 나중에 그린게 위!
        (손바닥놓기)
    (3) z-index 속성으로 숫자가 크면 위!

    9. 부모자격
    (1) 자식요소가 absolute일 때 부모자격으로 주는 경우가 다수임
        why?? 
        기존디자인이 그대로 유지되는 static한 속성을 가지는 
        포지션은 relative이기 때문이다. 단, 부모자격은 
        static이 아니면 모두 부모자격이 있다!!!!!
    __________________________________
    [ z-index란? ] -static이 아닌 포지션만 적용
    - 겹치는 포지션을 준 경우 위치순서를 정하는 디스플레이를 정하는 속성
    - z 는 화면방향의 층을 의미
    - 기본값은 0 -> 같은 층에 있는 모든 요소는 0
    
    ->기본값은 0이므로 마이너스 값은 static요소보다 아래로 내려감
        (이건 body보다 내려가서 선택이 안됨)
    **주의 : 
        z-index비교시에 형제레벨 먼저 비교 -> 하위자손 비교
        여러부분 z-index 주면 위아래 관계가 복잡해져서 정리가 어렵다


[ 3. absolute 포지션 ]
    - 절대적인 부모를 기준하여 위치를 이동하는 포지션
    - 부모자격을 따져서 기준을 삼는다
    (단, 위치속성값을 쓴 경우에만!!!!!!)

    1. absolute 포지션은 위치 이동값을 쓰기 전과 후로 나눌 수 있다.
    1-1. 위치 이동값이 없는 경우
        a) 본인보다 위에 있는 static한 요소를 존중하여 아래에 위치
            >>>>>젠틀 앱솔루트!!
        b) 어떤 자식 요소로 있을 경우 앱솔루트이면
        - 그 부모 박스에 부모자격이 없는 경우에도 그 부모박스 위치에
        그대로 가만히 위치한다.
            >>>>>젠틀 앱솔루트!!
        -> 앱솔루트 요소보다 아래쪽에 위치하고 있는 static한 요소는 
        앱솔루트를 인식하지 못하여 같은 자리에 위치함
        (즉, z-index처럼 위나 아래에 위치함)

    1-2. 위치이동값을 사용한 경우
        - 위치 이동값을 사용한 부분에 대해서만 앱솔루트가 위치를 잡을 때
                기준이 됨
        - 부모는 static이 아닌 요소가 부모
            **static이 아닌 position이란?
            relative / absolute / fixed / sticky
        - 위치 이동값을 쓰지 않는 부분에 대해서는
        부모를 찾지 않는다.(젠틀함!)
        >>>>>한쪽만 위치값을 주면 원래 포지션을 찾아감
        - 부모자격이 있는 요소중 가장 가까운것이 부모다
        - 만약 부모자격이 모두 없으면 보이는 화면(window)을 기준한다. 
        (보이는 화면은 body가 아니다! 스크롤이 생셔도 스크롤 위쪽에 
        보이는 화면을 기준한다.)
        - 또한!
            width나 height 값을 %단위로 줄 경우 부모자격을 가진 요소를 
            기준으로 그 크기를 잡는다!
        (일반적으로 %단위는 직계부모박스임.)

    2. absolute의 가로세로 크기가 배정되지 않은 경우
    일반적으로 block요소이므로 width:auto로써 부모박스 끝까지 차지하지만,
    앱솔루트는 내용만큼만 그 크기를 가진다.
    >>>>>앱솔루트 판타롱스타킹

    3. 원래 block이 아닌 요소를 absolute를 줄 경우 자동으로 
    display:block로 설정 됨. 이유는 자동크기를 설정할 경우 블록이 아니면
        크기를 설정할 수 없기 때문이다.
        -> 일반적으로 앱솔루트 포지션 요소는 블록이다!!

    4. 앱솔루트 끼리는 서로 겹친다!
    
    5. 앱솔루트 자식요소는 부모 박스가 overflow:hidden으로 셋팅되어
    있을 때 부모자격이 있어야만 숨겨진다.

    6. 위치 설정값과 같은 방향의 마진만 적용됨!
    예컨데 bottom으로 위치 이동하였으면 margin-bottom만 적용
    (위치 이동값이 없는 앱솔루트의 마진은?
    기본적으로 top,left를 기준하므로 같은 방향의 마진만 적용된다)

    7. 위치이동값의 초기화
    ex) top: 50px -> top: auto;
    초기화는 언제 함?
    기존에 셋팅 된 위치이동 값을 다른 기준으로 변경 할 경우
    초기화를 사용한다.
    ex) top: 30px;
    bottom기준으로 변경 할 경우
    top: auto;
    bottom: 100px;

    8. 위치 이동값을 전부 다 쓰는 경우도 있다
    부모박스를 가득 채우거나 일정 위치를 잡고 크기가 유동적이여야 할 때
    ex) 부모박스를 채우는 앱솔루트는?
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    (단, width, height값을 설정 하지 않음)

 [ 4. fixed 포지션 ]

    1. 보이는 화면을 기준한 포지션이다!
    -> 대부분의 속성은 absolute와 같으나
    부모만 다르다고 보면 된다

    2. 스크롤이 내려갈 때 요소가 화면에 멈춰있다.

    3. 위치속성값을 설정하지 않으면 젠틀하다!
    -> 젠틀픽스드!!!

    4. 크기설정을 하지 않으면 내용만큼만 커진다
    -> 픽스드 판타롱스타킹

    5. 인라인 요소도 fixed를 주면 block으로 자동전환 된다.

    6. 부모요소가 아무리 많이 싸여있어도 fixed를 주면
    화면을 기준하여 위치를 잡는다.

    7. 이미 부모가 fixed이면 자손요소는 fixed를 할 필요가 없다.

    8. 활용도
    1) 스크롤에 관계없이 화면 고정 시
    2) 화면 바깥에 숨겼다가 나타나기를 할 때

    (유의사항: 배경고정과의 차이
    배경고정 : 보이는 화면을 기준한 박스에 배경이미지를 고정
                박스가 움직이면 배경이미지도 안보이게 됨.
    픽스드 : 화면기준으로 고정을 하기 때문에 화면이 움직여도 고정)

[ 5. sticky 포지션 ]

    1. 위치값 top 설정에 따라 화면에 고정

    2. 원리: 처음에는 relative하게 가만히 위치를 
    점유하고 있음(left값이 적용됨) top값을 셋팅한 경우
    그 top값은 보이는 화면 최상단으로부터 위치값이 됨! 
    스크롤로 이동 시 sticky요소가 셋팅 된 값 위치를 
    만나는 순간 fixed와 같이 화면에 고정된다.

    3. sticky적용 구간
    감싸고 있는 박스가 기준이 됨
    **주의
    1) 전체 스크롤에 적용 시 body바로 아래 자식요소에
    위치해야 함
    2) 부분 스크롤 적용 시 부모요소중
    overflow: auto, hidden, scroll이 적용 된 경우 
    스티키 작용 안함!
    3) 부분 스크롤 적용 시 박스 내부에서만 보이는 
    화면의 기준이므로 무조건 height값이 셋팅 되야함
    height: auto 또는 height값이 없으면 작동 안함!!
    (높이 값을 기준으로 작동하기 때문임)

<meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- 
        [ 뷰포트(viewport)란? ]
        - 모바일 기기에서 볼때 모바일 기기의 랜더링 화면사이즈를
        일반적인 물리적 크기의 픽셀로 변환해 주는 메타태그임
        - 미디어쿼리를 사용하는 웹 페이지에서 필수!!!

        mata  요소 속성 name="viewport" 로 설정
        content 속성에
        1) width=device-width 
            : 가로픽셀크기를 디바이스 물리적크기와 일치시킴
        2) initial-scale=1.0
            : 물리적크기를 그대로 쓸때 1.0을 사용
            (1보다 작게하면 축소, 1보다 크게하면 확대)

        예) 아이폰 6플러스의 물리적 가로크기는 414px인데
            디스플레이할때는 1080px로 보여진다!
            이때 viewport를 쓰면 414px로 변환해서 보여준다!

    [ 미디어쿼리(Media Query)란? ]

        - 디바이스의 가로 사이즈에 대해 계속된
        질의(Query)를 브라우저에 함으로써 사이즈
        변경 시점에 필요한 CSS를 적용하여 디자인
        변경을 할 수 있도록 구현된 CSS 코딩기법

        - 반응형(적응형)웹을 구현하는 핵심기술

        1. 반응형웹(Responsive Web) :
        미디어 화면크기에 따라 종합적인 변경사항을
        기술적으로 다룬 사이트

        2. 적응형웹(Adaptive Web) :
        미디어 화면크기에 따라 레이아웃 등의 CSS로
        요소의 속성변경을 다룬 웹사이트

        - 우리가 CSS 코딩으로 구현하는 것은 적응형웹이다!
        즉, 적응형웹은 반응형웹의 일부분이다!
        하지만 일반적인 명칭으로 반응형웹으로 부른다!

        [ 구현방법 ]

        @media only screen and (max-width:최대px) and
        (min-width:최소px){
            CSS코딩구역
        }

        1) @media : 미디어쿼리 선언부

        2) only screen (또는 screen) : 회피코드
            -> 미디어쿼리를 아는 브라우저만 읽어라!
            -> only 를 쓰면 구버전 user agent 는
                미디어쿼리를 읽지 못하게 하는 것!
            (현재는 only를 쓴 것과 안쓴것의 차이가 없음!)

        3) max-width : 최대사이즈
            -> 반드시 px단위를 사용함, 소괄호 사용함!

        4) min-width : 최소사이즈
            -> 반드시 px단위를 사용함, 소괄호 사용함!

        -> 최대, 최소 사이즈는 표기된 사이즈를 포함함

        -> 최대 사이즈만 쓸 경우 :
            - 기준 사이즈 이하가 모두 포함됨
            - 큰 사이즈 부터 작은 사이즈 순으로 코딩해야
            제대로 적용됨!(하위 사이즈가 덮어씀)

        -> 최소 사이즈만 쓸 경우 :
            - 기준 사이즈 이상이 모두 포함됨
            - 작은 사이즈 부터 큰 사이즈 순으로 코딩해야
            제대로 적용됨!(상위 사이즈가 덮어씀)

        5) and : 구문 사이 연결자
            -> 주의사항 - and 앞뒤공백 필수!


        __________________________________________

        [ 웹페이지 가로/세로 모드 인식하기 ]

        1. 가로모드 -> (orientation:landscape)
            - landscape는 "풍경"이란뜻

        @media (orientation:landscape) {
            가로모드 CSS
        }

        2. 세로모드 -> (orientation:portrait)
            - portrait는 "초상화"란뜻

        @media (orientation:portrait) {
            세로모드 CSS
        }

        가로모드와 세로모드 변경코드!!!
            -> 가로/세로 모드는 그 길이가 더 긴것을
                기준한다! 모바일 전용이 아니다!
                -> 모바일 화면의 제한을 주려면 가로크기의
                한계값을 설정하는 방법을 사용한다!
                예) 
                @media screen and 
                (orientation:portrait) and 
                (max-width:1000px){ CSS코드 }
        __________________________________________    


        [ 미디어 쿼리 코딩시 주의사항! ]

        1. 기존 CSS 선택자와 동일하게 코딩한다!
            (그래야 덮어쓰기가 원활하다!)

        2. max-width 로 셋팅한 후 큰 사이즈 부터 작은 사이즈
        순으로 코딩한다! (min-width는 순서반대!)
        -> 그래야 같은 속성 덮어쓰기가 가능함!

        3. 미디어쿼리를 외부CSS파일로 만들어 사용할 경우
            @import방식으로 호출하면 적용되지 않는다!
            이유는 미디어쿼리는 덮어쓰기 방식이므로
            기존 CSS코드보다 아래에 있어야함!!!!
            link방식으로 html코드 상단에 기본 CSS 외부파일보다
            아래에서 호출하면 된다!!!

        예) 
        <head>
            <link rel="stylesheet" href="일반CSS">
            <link rel="stylesheet" href="미디어쿼리CSS">
        </head>

        [ 플렉스 디스플레이 박스 ]
                flex 란? - flexible(유연한-에서 나온말)

                - 가변적인 자식요소를 컨트롤하기 위해
                CSS3에서 새롭게 선보인 display 기술

                [ 플렉스 셋팅법 ]
                1. 대상: 컨트롤할 요소들의 직계부모요소
                2. 등분할셋팅:
                 - 자식요소를 같은 비율로 채울 때
                 자식요소에 flex속성값을 1로 쓰면 된다!
                3. 일반적인 셋팅:
                 - 특정크기나 내용이 있는 블록요소인 자식을
                 옆으로 흐르게 한다(flex셋팅 일단 불필요!)

                 __________________________________________


                 [ flex 속성 : 플렉스 자식요소에 주는 속성 ]
                    -> flex : 한번에 아래 3가지 속성을 줌

                    flex: 1 숫자하나만 쓰면 
                    flex: 1 1 0 과 동일
                    해석) 
                    커질래? 응(1), 작아질래? 응(1), 가로크기 0 (설정없음)

                    따로 설정시 아래와 같다!
                    flex-grow: 1;
                    flex-shrink: 1;
                    flex-basis: 0;

                    1) flex-grow: 1 | 0 -> 커질래? 1 응 | 0 아니
                    2) flex-shrink: 1 | 0 -> 작아질래? 1 응 | 0 아니
                    3) flex-basis: 설정값(px,%,em,rem,vw등)
                    -> width 가로크기를 설정하는 속성
                    -> 만약 0을 쓰면 속성값 없음!
                _____________________________________________

                    
                [ 자식요소 속성 중 order란? ]
                - 원하는 순서로 정해서 박스가 나열되게함!
                - flex-direction 속성으로 방향을 정할 수 있다!
                (order를 지정하면 이 순서를 기반으로 방향을 정한다!)
                

                속성명-> order: 순번
                순서를 정할 요소에 준다
                예)
                 <li style="order:3"></li>
                 <li style="order:1"></li>
                 <li style="order:2"></li>
                 <li style="order:5"></li>


                소스참고:
                https://www.w3schools.com/css/tryit.asp?filename=trycss3_flexbox_order_2

                _________________________________________

                [ justify-content 속성 ]

                - 진행방향정렬속성 (justify 양쪽정렬의 뜻)
                - content 는 진행방향으로 여러개의 
                아이템요소가 있으니까 컨텐트임!

                1) flex-start : 처음위치(기본값)
                2) flex-end : 끝위치
                3) center : 중앙
                4) space-between : 
                    아이템요소 양쪽끝에 붙고 사이간격 일정
                5) space-around : 
                    아이템요소 양쪽간격 일정
                6) space-evenly : 
                    아이템요소 양쪽과 사이간격 일정

                _______________________________________

                [ align-items 속성 ]

                    - 진행방향의 수직 정렬 속성
                    - 수직방향의 아이템(요소)이 하나씩일때 사용

                    1) flex-start : 처음위치(기본값)
                    2) flex-end : 끝위치
                    3) center : 중앙
                    4) stretch : 수직방향 부모박스에 꽉채워 늘림!
                    (단, height값이 auto여야함!)
                    5) baseline : 각 요소에 글자가 있다면 
                    글자기준선(baseline)을 기준으로 정렬함!
                    (글자의 line-height를 변경해서 적용해봄!)

                _____________________________________________

                [ flex-direction 속성 ]
                    - 진행방향과 순서를 정함

                    1) row : 좌->우(기본값)
                    2) row-reverse : 우->좌
                    3) column : 위->아래
                    4) column-reverse : 아래->위

 [ float속성을 이용한 옆으로 가로방향 정렬 ]
                1. 옆으로 보낼 블록박스의 float:left;
                2. 부모박스에 맞추려면 height:100%;
                3. 등분할 width: 100%/나눌수;
                4. 부모박스의 가상요소로 끊어주기 
                    clear:both 설정
margin-left: auto;
                /* 
                    선택요소의 떨어뜨리려는 방향으로 마진을 auto처리하면
                    flex박스 오른쪽 끝으로 이동시켜준다!
                */
[ flex-shrink 속성 ]
                부모박스가 줄어들 때 같이 자동으로 줄어들래?
                설정의 기본값은 1(true)이다. 즉, 줄어든다.
                0으로 변경하면 자기크기를 유지한다.

            [ 그리드 디스플레이 ]

    - 가로,세로 양방향 레이아웃을 위한 디스플레이 속성
    - 주요 속성:
    1. grid-template-colums
        - 가로방향 width폭을 지정하는 속성
        - 값은 순서대로 값을씀 (개수만큼 한줄 컬럼결정)
        - 반복을 사용할 수 있다
            -> repeat(개수,설정값)
        - 설정값: px,%,vw,rem 등 구체적인값
            또는 비율값 -> 숫자fr (가로크기 전체의 비율)
            fr은 fraction에서 나온말
            예) 1fr 2fr -> 1:2비율 
    2. grid-template-rows
        - 세로방향의 height값을 지정하는 속성
        - 값은 순서대로 값을씀
        - 나머지는 1번과 동일
        - 만약 이 값을 설정하지 않으면 모든 박스에 대한
        기본비를 유지함!(내가 원하는 비는 별도로 설정함)
        -> 기본비에 대한 기준은 내부컨텐츠임
        (이미지라면 이미지 기본비를 기준함)
        
    3. grid-column-gap
        - 가로방향 사이간격
    
    4. grid-row-gap
        - 세로방향 사이간격
    ________________________________
    
    5.  가로정렬, 세로정렬은 flex와 개념상 동일하다! 
    - 한줄일때 (진행방에 여러개있을 경우)
    justify-content -> 가로진행방향 정렬
    align-content -> 세로진행방향 정렬
    - 여러줄일때
    justify-items -> 가로방향 다중 정렬 (flex에 없음!)
    align-items -> 세로방향 다중 정렬

    ___________________________________

    그리드 사용 예시 사이트: 매치 리스트
    https://www.matchroomboxing.com/

    /******************************************** 
            [ 가로 그리드 템플릿 ]
            grid-template-columns : 기둥의 두께 세팅
        ********************************************/
        /* 
        1. 가로사이즈 단위를 띄어쓰기로 나열
            개수만큼 그 크기의 세로 column이 생성
            grid-template-columns: 100px 200px 300px 400px;

        2. fr단위를 나열
            가로전체를 기준하여 비율을 설정한 컬럼이 생성
            fraction(부분)
            ex) 1fr 3fr -> 1:3 (전체기준)
            grid-template-columns: 1fr 3fr;

        3. repeat(수치의 반복수, 반복수치)
            -> 반복수*반복수치개수 = 컬럼수
            -> 단순하게 사용 할 경우 repeat(컬럼수,1fr);
            grid-template-columns: repeat(3,100px 1fr 2fr);
        */
        grid-template-columns: repeat(5,1fr);
        /******************************************** 
            [ 세로 그리드 템플릿 ]
            grid-template-rows
        ********************************************/
        /* 
        1. 구체적인 수치를 나열
            나열한 개수만큼 그 수치로 세팅, 나머지는 auto
            grid-template-rows: 100px 200px 300px 400px;
        
        2. fr단위를 나열
            fr을 쓴 만큼 높이값 전체에서의 비로 세팅 됨
            grid-template-rows: 1fr 3fr 5fr 2fr;
        
        3. repeat(수치의 반복수, 반복수치)
            ->colum과 유사
            grid-template-rows: repeat(4,100px);
        */
        /* 4. 모든 높이값 동일하게 세팅 
        grid-auto-rows: 400px; */

        /***************************** 
            [ 수평방향 간격 ]
            grid-column-gap
        *****************************/
        grid-column-gap: min(1vw,10px);
        /***************************** 
            [ 수직방향 간격 ]
            grid-row-gap
        *****************************/
        grid-row-gap: min(1.5vw,15px);

[ 개별적 변경하기 - 그리드 위치와 크기 변경 ]
        방법) 개별요소에 column 과 row의 시작/끝번호를 지정함
        grid-column:시작/끝
        grid-row:시작/끝

    /************************************* 
    
        [ 그리드 위치 영역 속성 ]

        1. 가로방향 위치속성
            grid-column : 시작위치번호 / 끝위치번호;

        2. 세로방향 위치속성
            grid-row : 시작위치번호 / 끝위치번호;

        -> 각 위치값은 그리드 기준선 번호를 참고함
        (브라우저에서 그리드 소스 버튼을 클릭하여
        볼 수 있음!)

        >>>>> 셋팅시 유의사항 <<<<<<<
        - grid-column 을 설정할때 만약 그리드범위에
        넘치면 자동으로 아랫줄로 떨어진다!
        그러므로 grid-row를 따로 잡아줄 필요가 없다!
        단, 별도의 위치를 세로방향으로 변경해야할 경우
        grid-row를 설정해야 한다!

    [ CSS에서 변수 사용하기 ]

        1. 변수 셋팅법
        :root{
            --변수명1: 값1;
            --변수명2: 값2;
            --변수명3: 값3;
        }

        2. 변수 호출 사용법
        var(--변수명)

        ->>> 변수는 언제 사용하나?
        - 같은 값이 여러부분에서 사용될때
        미디어쿼리 등에서 변경이 필요한 경우
        변수값만 변경하면 복잡한 값변경이 대체됨!

    [ 3D 원근설정 ]
        1. 셋팅위치 : 3D원근 설정을 할 대상의 부모요소
        2. 설정방법 : perspective: 수치;
        -> 수치는 px단위로 숫자가 클수록 소실점이 먼것이므로
         각도가 작아짐(이 거리는 기준점에서 소실점까지의
        거리임)
perspective: 480px; /* 소실점까지의 거리 */
    perspective-origin: 50% 50%;
[ 뷰포인트(관찰자위치) 변경옵션 ]
        perpective-origin : 가로 세로;
        - 가로축: left, center, right, px, % 등 단위
        - 세로축: top, center, bottom, px, % 등 단위
        -> 두 값 중에 하나만 쓸 수 있고 복합일 경우
        2가지를 같이 셋팅함!
[트랜스폼 회전축 변경속성]
        transform-origin: 가로축 세로축
        - 가로축: left, center, right, px, % 등 단위
        - 세로축: top, center, bottom, px, % 등 단위
/* 애니메이션: 이시이지반방마 */
    /* 처음에 밀어 열리고 끝상태 유지 */
    animation: first-open-door-ani 1s ease-in-out forwards,
    /* 다시 당기면서 열고 닫고 계속됨 */
    open-door-ani 2s ease-in-out 1s infinite alternate;

    animation-play-state: paused;
    /* 처음에 애니메이션 멈추기
        animation-play-state 속성
        1. running : 작동
        2. paused : 멈춤
    */

/* 문짝부모에 오버시 문짝애니작동! */
.cont:hover .door,#elsa img{
    animation-play-state: running;
}
.cont:hover #elsa img{
    animation-play-state: running;
}

[ 마우스 오버/아웃 관련 이벤트 차이점 ]
1. mouseover / mouseout : 요소 자체를 기준
2. mouseenter / mouseleave : 요소 경계선을 기준
-> 둘의 차이는 이벤트 버블링에 있다.
-> 경계선 기준의 이벤트인 mouseenter / mouseleave는
자체요소에서만 발생하고 버블링 되지 않는다.
-> 자손요소에서 버블링되어 발생하는 mouseover/mouseout으로
셋팅 할 경우 빈번한 이벤트 발생이 문제가 될 수 있음
이때는 mouseenter / mouseleave를 사용 할 것을 w3c가 권고함!


큐브를 직접 싸고 있는 대상
[ 전체 랩핑박스 : .wrap ]
    1. 화면고정필수(fixed)
    2. 화면과 같은 크기설정
    3. 스크롤 셋팅(랩핑박스에서 스크롤됨!)
    4. 원근설정(perspective)
preserve-3d 적용범위박스 + 높이값설정박스
[ 입체로 설정하기 ]
        - 입체로 설정할 요소의 부모박스에
        아래와 같이 설정해준다!
        (부모는 싸고 있는 요소 또는 상위요소)
        transform-style: preserve-3d
        - 기본값은 flat : 2D
        - preserve-3d : 3D

[ 커서 이미지로 보이기 ]
    cursor: url(이미지경로) x위치 y위치,auto 
    -> 사이즈등의 이슈로 안나올 수 있으므로 auto/pointer등 대체항복을 뒤에 콤마하고 써야함
    -> 이미지 커서의 위치는 맨위 왼쪽 끝이다.
    -> 위치변경 옵션 x, y 위치는 단위없으면 자동 px, 이미지 크기보다 크면 처리안됨
    */
    /* cursor: url(../images/door.png), auto; */
    /* cursor: url(../images/door.png)200 50, auto; */
    /* 가로 200px 세로 50px위치에서 나옴 */
}보이는 화면만큼 높이값을 줄 때 100%의 의미는? body는 html을 기준함
                html은 무엇을 기준하는가? 보이는 화면을 기준함(window)
                그래서 보이는 화면만큼 확장된다.
html에 배경을 넣지 말고 전체 배경은 body에
배경 반복여부 bgr 
                repeat-x : x축 반복
                repeat-y : y축 반복
                repeat : 모든 축 반복(기본값)
 화면고정 bga 
                배경고정값은 fixed
                고정의 이미는 스크롤시 배경 고정
배경위치 bgp
                값 : 가로 세로
                1. 가로방향 :left, center, right
                2. 세로방향 : top, center, bottom
                - 수치값 : px, %, em 등 여러단위 사용가능
                위치값의 가로는 left, 세로는 center가 기본값
                
                방향 별 개별 속성은?
                background-position-x: 값;
                background-position-y: 값;
6. 배경이미지 크기 bgz : 가로 세로 
                정해진 값 : 
                1) contain 이미지가 화면에 채워지나 모두보임
                    안잘림
                background-size: contain;
                2) cover : 이미지를 박스에 모두 채움
                    잘림
                background-size: cover;
                3) 수치값 : 가로 세로 
                    하나만 주면 이미지가 비율 유지함
                    둘 다 주면 찌그러짐
                background-size: 400px auto;
                background-size: 200px 200px;
[ 배경 한번에 쓰기 ]
                background : 배경색 이미지 반복 고정 위치 / 크기
                bg : 색이반고윙/크
                background: lightyellow url(./imgs/bg_mainvisual.jpg) no-repeat fixed center/cover;

                **주의
                만약 배경 한번에 쓰기를 개별세팅 아래에 놓으면
                기존 세팅이 모두 지워짐
                따라서 개별 세팅이 더 아래쪽에 코딩되어야 한다

    [ CSS의 display 속성이란? ]

            - 브라우저에서 화면에 요소를 어떻게 보이게 할지
            결정해 주는 속성
            - 요소의 역할은 내용구분!

            - 요소의 display는 크게 2가지

            1. block 요소

             (1) 표현법 : 
                display : block;
             (2) 기본적으로 block인 요소들
             h1~h6, div, p, figure, header, nav, blockquote
             (3) 특징
                1) 옆에 다른 요소가 올 수 없다(블록킹)
                2) 내용을 구분하는 그룹화 요소다
                3) 박스 모델의 디자인 속성이 전부 적용됨
                    : width, height, border, padding, margin
                4) 가로크기를 주지 않으면 부모박스 끝까지 같다
                    : width: auto;
                5) 세로크기를 주지 않으면 내용만큼 늘어난다
                    : height: auto;
                6) 위, 아래간 블록요소 마진은 중첩된다
                -> 큰 마진이 작은 마진을 포함한다
                7) 박스의 지정된 가로, 세로 크기는 컨텐츠 영역의 크기
                   border와 padding을 주면 박스크기가 늘어남
                   ->늘어나는 박스를 content box라고 함
                
                   [ 보더와 패딩을 박스크기에 포함여부 결정속성 ]
                    1) box-sizing : border-box; (bxb)
                    -> 크기를 지정한 박스에 대한 패딩과 보더를 포함
                    (즉, 크기가 늘어나진 않음)
                    2) box-sizing : content-box; (bxc)
                    -> 크기를 지정한 박스에 패딩과 보더를 주면
                    준 만큼 늘어남!

            2. inline 요소

             (1) 표현법 :
                display : inline;
             (2) 기본적으로 inline인 요소들
                a, img, span, b, i, em, strong, q 등
             (3) 특징 : 
                1) block 요소를 포함할 수 없다.
                    ex) <span><div></div></span>
                    **주의 : 인라인을 블록으로 출신을 변경해도 
                            원래 인라인이면 블록을 쌀 수 없다.
                    예외) a요소(너무 많이 써서 규칙 변함)
                2) width, height크기가 적용되지 않는다.
                -> 내용만큼 늘어남!
                3) margin은 양쪽만 적용 됨!
                -> 위 아래 마진은 적용되지 않는다. 
                4) padding 은 디자인 상 모두 적용되는 것으로 
                보이지만 실제로 다른 인라인 요소를 밀지 못함!
                5) boder 는 패딩과 마찬가지로 디자인 상 모두 
                적용되지만 실제로 밀 수 있는 것은 앞 뒤 방향뿐이다
                
                참고) 인라인요소의 위아래 간격은
                line-height로 설정함!

                [ 예외 인라인 요소 : img ]

                -> 이미지는 인라인 요소지만
                width, height, margin, padding, border
                모두 적용되고 실제로 영향을 미침
                (이미지는 기본적으로 한쪽크기만 주면
                나머지는 비율에 맞게 자동 설정 됨)

            [ display 출신변경 ]
                display: block;
            [ display를 숨기는 방법 ]
                display: none;
                ->태그는 그대로 있고 화면상에 출력만 안됨

            _____________________________________________________

            [ 초기화나 변경 세팅이 필요 없는 순수태그 ]
            1. 블록 대표주자 : div
            2. 인라인 대표주자 : span
            ______________________________________________________
            
            3. inline-block 요소
             (1) 표현법 : 
                display : inline-block;
             (2) 기본적으로 inline-block인 요소들
                button, input 등
             (3) 특징 : 
                1) 인라인처럼 한줄에 온다
                2) 블록처럼 박스모델 속성이 적용된다 whbmp
                참고) button요소의 경우 
                 box-sizing:border-box가 기본값

            [ 기타 display ]
            4. table : 테이블 요소
            5. flex : 유동적인 레이아웃 요소
            6. grid : 그리드 레이아웃 요소

            [ 블록요소의 float ]
            - 필요성: 블록요소는 옆에 다른요소가 올 수
             없음 그래서 옆으로 흐르게 하는 속성셋팅이
              필요!
            - float 속성값:
            1) left -> 설정요소는 왼쪽에 다른요소는
                        오른쪽으로 흐르게 해줌
                        왼쪽으로 흐르게 해줌
            
            [ float만 설정한 경우 생기는 문제! ]
            - 하위요소가 float설정된 요소를 인지하지 못해
            위로 올라오게됨
            - 이것을 위해 다음 속성셋팅 필수!
            - 대상: float을 끊어줄 블록요소
            - clear 속성값:
            1) left -> 이전 요소가 float:left일때
            2) right -> 이전 요소가 float:right일때
            3) both -> 이전 요소가 어떤 경우에 모두 지우기적용

            -> 일반적으로 이전요소의 float을 
            적용받지 않을 요소에게 clear:both를 준다!
            (경우1)

            [ 부모요소가 자식요소의 float때문에 망가질때 ]

            1. 마지막 블록자식요소를 넣고 clear:both를함
            (경우2)

            2. 가상요소 ::after로 clear:both설정함
            (경우3)

            3. float된 자식요소의 부모박스에 
                overflow:hidden 처리를 함
                -> 자식요소 숨기기를 할 경우
                float으로 요소가 유동적인 상태를
                마무리하는 속성 내부적 셋팅됨!

                -> 단점: 만약 자식요소가 부모요소
                바깥으로 나가야 할 경우 숨겨져서
                제약이 따르게 됨!!!
                (이럴경우 위의 1,2번을 쓸것! 특히 2번추천!!!)

            4. 높이값을 강제로 주는 방법도 있음(비추;;;;)

            _______________________________________

            [ 기존에 float셋팅된 요소 없애기 ]
            float:none;

            [ flaot에 의한 진행방향 ]
            float:left 만 사용 : 왼쪽 -> 오른쪽
            float:right 만 사용 : 오른쪽 -> 왼쪽
            (경우5)

            [ 가상클래스란? ]
        - Pseudo-class 슈도클래스 라고도함
        - 의미: 마치 클래스를 준것 처럼
        선택하여 디자인을 변경할 수 있다
        ___________________________________

        1. 자식선택 가상클래스
        - 조건: 한 부모요소 아래에 같은 종류의
        태그로 구성되어 있어야함!
        예) ul>li 이와 같이 ul아래 li로만 구성됨
            div>div 같은 종류의 직계자식으로만
            구성되어야함
        - 선택방법:
            요소:first-child 첫번째자식
            요소:last-child 마지막자식
            요소:nth-child(n) n번째자식
                            - n은 1부터

        *******************************

        2. 종류가 다른 자식선택 가상클래스
        - 한 가지가 아닌 여러 종류의 자식요소
        로 구성된 경우 자식을 선택하는 방법
        - 선택방법:
        요소:first-of-type
            - 같은타입(요소)중 첫번째
        요소:last-of-type
            - 같은타입(요소)중 마지막
        요소:nth-of-type(n)
            - 같은타입(요소)중 n번째
                            - n은 1부터

        ********************************

        3. 마우스 오버시 요소 변경 가상클래스
        - 마우스가 요소에 오버되면 자기자신 또는
        자손요손 요소의 디자인을 변경할 수 있다
        - 선택방법:
        요소:hover

        ************************************

        4. a요소 관련 가상클래스
        - a:hover 오버시
        - a:link 링크시
        - a:visited 방문후 표시
        - a:active 마우스를 누르고 있을때 

        5. 포커스 가상클래스
        - 요소명:focus{}
        - 포커스란 어떤 요소가 마우스로 클릭되거나
        터치되었을때 그요소에 촛점이 가게 되는데
        이런 상태를 포커스상태라고 한다!
        - 이 상태에 대한 디자인을 별도로 줄 수 있다
        - 입력폼요소에 많이 사용된다!
        - 오해하지말자! 클릭이벤트와 다르다!
        클릭이벤트는 클릭한 순간 이벤트가 사라지지만
        포커스는 요소가 클릭되어 활성화된 상태를 유지함
        - 포커스를 없애고 싶으면 다른요소를 클릭하면 됨
        - 포커스가 없어지는 상태를 blur(블러)라고함

        참고) 탭키를 눌러서 a요소의 포커스를 이동시킬 수 있음

        4번 li 이후 모든 li를 전부 셋팅하기
틸드(~) 는 다중형제선택
                선택요소~요소명
                -> 선택요소 뒤에 있는
                모든 형제 요소를 선택함!
.part1 li:nth-child(4)~li {
body .part1 li:last-child {
}
:last-child가 적용되지 않은 이유!
                위에서 적용한 틸드(~)선택자가
                한단계 더 선택했으므로 우선순위가
                올라갔다!
                이것의 우선순위를 쉽게 변경하려면
                상위요소를 써주면 된다! 
                (호가호위-여우뒤에 호랑이 효과!)
                (!important는 되도록 쓰지말것!)


        [ CSS 선택자 우선순위 ]

        - 기본적으로 같은 선택자일 경우 아래쪽에 코딩한
        것이 기존값을 덮어쓴다!

        - 코딩순서와 관계없이 아래의 순서로 우선권을 가진다

        1.인라인코딩 : 요소 내부에 속성으로 style=""
        2.아이디요소 : #아이디명
        3.클래스요소 : .클래스명
        4.타입요소 : 일반 태그명

        인라인 > 아이디 > 클래스 > 타입

        - 위의 일반적인 우선순위와 상관없이 무조건 적용
        하기 위해 !important 키워드를 속성값 마지막에 
        추가할 경우 무조건 적용된다
        (주의: 되도록 쓰지 말것!)

        - 같은 클래스일 경우 다른 선택자가 더 추가되면
        우선순위가 올라간다!
        
        예) li:nth-child(3){코딩}
            li:nth-child(3)~li{코딩} -> 우선권!
            위의 선택자보다 한 단계 더 선택했으므로
            우선순위가 상위다!

        [ 우선순위 상위 적용방법 ]

        1. 위의 우선순위를 봐서 부모요소를 써주면
        기본 선택자보다 우선한다.(이 방법 추천!!!)
        예) .my span{코딩}
            #you .my span{코딩} -> 우선권!!!
            -> 호가호위! 호랑이 앞에 여우!
        2. 강제순위 올리기: 속성값 맨뒤에 !important
        
        -> 주의사항: 인라인보다 더 강하므로 JS코딩시
        이런 셋팅이 있으면 JS가 적용되지 않는 경우가
        발생한다! 따라서 사용을 최대한 신중하게 해야함

                /* 1. 짝수번째
        nth-child(even) -> 짝수번째 */
        #rdo1:checked~ul li:nth-child(even) {

                /* 5. 1부터 20번째 :nth-child(-n+20)
        nth-child(-n+20) 
        -> 1부터 20번째 :nth-child(-n+20)
        n에 0부터 대입된 결과임! 
        -n이므로 뒤에서부터 선택되어 첫번째까지
        선택됨 -> (20-n)라고 쓰면 문법오류임! */
        #rdo5:checked~ul li:nth-child(-n+20) {
        /* 6. 21부터 37번째 
        li:nth-child(20) ~ li:nth-child(-n+37)
        -> 출발은 20번째 요소 뒤인 21번부터 출발
        n에 0부터 대입된 결과임! 끝에서부터 거꾸로
        번호를 선택함!*/
        #rdo6:checked~ul li:nth-child(n+20)~:nth-child(-n+37) 


        [ 가상요소란? ]
            - Pseudo-element:슈도엘러먼트
            : 데이터를 담을 수 있는 요소일 경우
            맨앞과 맨뒤에 이미지나 글자를 넣을 수 있고
            또한 첫글자나 첫째줄 글자라인의 디자인을
            마치 요소로 싼것처럼 디자인을 변경할 수 있는
            CSS의 요소 추가 방법이다!
            -> 태그가 없는데 있는 것 같이 사용하니 가상요소다!

            **********************************************
            - 가상요소 표기법
            콜론을 선택요소 뒤에 붙여서 2개사용한다 
            ::before / ::after / ::first-letter / ::first-line
            - css3이전에는 콜론을 1개만 썼었으나 가상클래스가
            콜론을 하나쓰므로 이를 구분하기 위해 2개쓰는 것으로 변경됨
            (하나만 써도 적용은 된다...)

            1. ::before -> ~전에 의 뜻이므로 요소 맨앞에 뭔가추가
            -> 필수속성 content 속성에 
            content: "글자" -> 글자출력
            content: url(이미지경로) -> 이미지출력

            2. ::after -> ~후에 의 뜻이므로 요소 맨뒤에 뭔가추가
            -> 필수속성 content 속성에 
            content: "글자" -> 글자출력
            content: url(이미지경로) -> 이미지출력

            -> before와 after는 모든 요소의 반드시 하나씩 사용가능
            바지에 앞주머니, 뒷주머니가 하나씩 있다!
            -> 기본개념: 선택요소 맨앞이나 뒤에 span태그를 쓴것과 유사, 이미지를 넣으면 이미지 태그와 유사

            3. ::first-letter 
            - 선택요소 내부의 글자 중 첫번째 글자를 마치 태그로 싼것
            처럼 디자인을 적용할 수 있다!
            - 단, 블록요소에만 적용(인라인요소를 블록화하여도 됨)

            4. ::first-line
            - 선택요소 내부의 글자 중 첫번째 줄만 마치 태그로 싼 것
            처럼 디자인을 적용할 수 있다!
            특징: 기존의 첫번째 줄이었던 글자가 내려가면 적용이 사라짐
            무조건 첫번째 줄에 온 글자만 적용된다!
            - 단, 블록요소에만 적용(인라인요소를 블록화하여도 됨)
        [ 최대가로크기 / 최소가로크기 설정 정리! ]

        1. max-width : 최대가로크기 제한
        -> 최대크기보다 작아지면 auto전환
        -> 값을 %로 줄경우 화면크기를 기준하여
        박스크기보다 작아질 경우 %가 적용된다!
        이때 보통 width크기가 설정되어 있다(.bx5예)

        2. min-width : 최소가로크기 제한
        -> 최소크기보다 커지면 auto전환

[ 최대높이값 / 최소높이값 설정에 대하여 ]

            1. max-height: 최대높이값 설정으로 제한함
            -> 최대높이보다 내용이 적으면 auto(내용만큼 늘어남)

            2. min-height: 최소높이값 설정으로 제한함
            -> 최소높이보다 내용이 많으면 auto(내용만큼 늘어남)
[ 트랜지션으로 애니메이션 설정하기 ]
                - 트랜지션이란? CSS 속성값이 변경되는 과정을
                애니메이션으로 보여주는 속성
                - 마우스 오버시 혹은 미리 셋팅 된 클래스에 설정하여
                JS로 클래스를 요소에 부여해도 적용할 수 있다

                - 형식
                transition: 속성명 시간 이징 지연시간(속시이지~)
                
                - 설정값 : 
                1) 속성명 - 애니메이션 지정 대상속성
                예컨데 height 값을 쓰면 height에 대한 애니메이션만 나옴
                -> all 또는 생략하면 모든 CSS 변화과정이 애니메이션으로
                연출됨

                2) 시간 - 애니메이션 작동시간
                    -> 초단위로 표시, 뒤에 s라는 단위 씀
                    -> 초단위에 0.5s 등 0.소수의 경우 
                    0을 생략하여 .5s로도 사용

                3) 이징(easing) - 애니메이션 가속도
                    ease-in : 시작할 때 천천히
                    ease-out : 끝날 때 천천히
                    ease-in-out : 시작과 끝에 천천히
                    linear : 등속도
                    ease : 약한정도로 시작과 끝에 천천히(기본값)

                -> 그 밖에 다양한 수치로 가속도를 설정 가능함!
                (베지어곡선)

                4) 지연시간 - 애니메이션 시간 전 대기시간
                    - 초단위 뒤에 s 사용
                
                -> 왜 속성값을 쓰게 했나?
                속시이지 순서대로 속성별 설정을 모두 다르게 여러개를
                설정가능!! 아주 효과가 좋음

                예시) transition : width .3s ease-in,
                                    height .5s ease-out .5s;
                    - 가로크기는 0.3초간 처음에 천천히
                    그리고 세로크기는 0.5초간 0.5초부터 마지막에 천천히

                ->>> 트랜지션을 마우스 오버시 양방향 동일하게 셋팅하려면
                원본에 트랜지션을 주면 된다!!

                ->>> 기본 트랜지션을 없애는 설정은?
                    transition : none;
relative인 span에 top값을 %로 주면 적용안되는 이유:
            부모박스의 높이값이 auto이므로 기준을 정할 수 없어서 안됨
            만약 부모박스에 height값을 구체적으로 주면 %가 적용됨
width의 auto는 싸고있는 박스를 채우기 때문에 가로크기가
            내부적으로 설정 됨 그래서 %가 적용됨

        [ 웹폰트란? ]
            - 브라우저에서 사용할 수 있도록 서버에
            폰트를 올려놓고 브라우저가 이를 다운로드
            하여 화면에 폰트가 적용된 요소에서 사용
            할 수 있도록 개발한 폰트형식

            [ 웹폰트의 형식 ]
            1. woff(Web Open Font Format)
            - w3c에서 표준으로 지정한 웹폰트 형식
            - 2017년에 woff2까지 발표됨(압축률,전송속도향상)

            2. eot(embeded open type)
            - ms사에서 개발한 초기버전 웹폰트 형식
            - ie6 ~ ie8 에서 사용함

            3. ttf(true type font)
            - 구형 안드로이드 버전4.4에서 사용함

            (참고: 일반 PC에 설치되는 글꼴형식)
            1. ttf(true type font)
            - 애플사에서 개발한 속도가 빠른 폰트형식
            - 일반 브라우저 혹은 워드프로세서 등 에서
            많이 사용함

            2. otf(open type font)
            - ms+어도비 공동개발한 글꼴
            - ttf보다 정교한 3차원방식으로 글자를 표현함
            - 정교한 대신 무겁고 속도가 느린편임

            [ 웹폰트 코딩법 ]
            @font-face{
                font-family: 웹폰트명(내가지은이름);
                src: url(경로/글꼴명.woff) format("woff"),
                url(경로/글꼴명.ttf) format("truetype"),
                url(경로/글꼴명.eot) format("eot");
            }
            //format("eot") 읽어드리는 포멧팅(ttf인지 woff인지 써주면 프로그램빠름)
            -> 간단히 쓰기
            @font-face{
                font-family: 웹폰트명(내가지은이름);
                src: url(경로/글꼴명.woff) format("woff");
            }

            - 웹폰트의 글꼴명은 자유롭게 지정할 수 있다
            - src 에는 같은 글꼴을 여러형식으로 셋팅할 수 있다
            - 요즘은 이전형식인 eot, ttf 등 을 셋팅 안한다!

            [ 웹폰트 생성법 ]
            1. ttf 등의 일반 글꼴을 구한다.
            (구글폰트, 유료폰트 등)

            2. 웹폰트 변환 프로그램으로 파일을 변환한다
            - ttf(otf) -> woff 로 변환
            - 온라인 웹폰트 변환 사이트도 있다
            (onlinefontconverter.com 등)
            3. 실제 적용할 요소에 CSS 웹폰트 설정을 통해 셋팅한다

            [ 웹폰트가 안나오는 경우 ]
            1. font-face 설정에서 src경로가 부정확할때
            2. 폰트명이 잘못됐을때
            3. woff파일 변환에 문제가 있을때
            (오프라인 변환인 경우 온라인 사이트 변환을
            해보고 문제가 지속되면 비슷 다른 폰트를 
            구해본다! - otf파일이 에러율이 높다!)

            [ font-face 셋팅시 유의점 ]
            1. 폰트명은 font-family 에 써주는데 붙어있는
            영문일 경우 따옴표를 안써도 됨(경로도 마찬가지)
            그런데 띄어쓰기가 되어있다면 따옴표사용
            2. src 에 format을 지정해야 웹폰트 로딩 속도가
            빠르다(브라우저가 파일포멧을 보고 판단하므로!)
            3. 웹폰트 셋팅은 CSS설정 파일 상단에 셋팅해야함!

            [ 폰트 라이센스에 대하여 ]
            1. 무료폰트일 지라도 상업적용도에 대한
            언급이 있어서 제한이 되는 확인한다!
            2. 유료폰트를 불법으로 사용하면 법적으로
            제제를 받을 수 있다(구매후 사용한다!)
            - 특히 윤서체 주의!

            [ 무료폰트 사이트 ]
            구글폰트 : 
            https://fonts.google.com/

                        [ CDN 방식으로 웹폰트 불러오기 ]
            - Content Delivery Network
            즉, 컨텐트(웹폰트파일)를 가져와 네트워크로!

            - 호출방식:
            1. external 방식으로 불러오기
            - link요소를 사용하여 html 상단에 넣는다
            예) <link rel="stylesheet" href="cdn주소">

            2. import 방식으로 불러오기
            - @import 를 사용하여 css코딩구역 상단에 넣는다
            예) @import url(cdn주소)

            -> 결론적으로 위의 2가지 방식을 사용하면
            @font-face를 사용할 필요가 없다! 왜?
            불러온 파일에 이미 셋팅이 되어 있으므로!!!

            [ 구글폰트로 CDN하기 ]
            1. 구글폰트 사이트에서 사용할 웹폰트를 선택한다
            2. link태그 방식 / @import방식 중 선택하여
            소스에 붙여 넣는다
            3. 지정된 CDN 웹폰트 이름으로 적용한다


            [ link방식과 @import방식 중 어떤것을 더 많이쓰나? ]
            - 외부 CSS를 사용한다면 그 파일에서 @import하여
            하나의 파일로 만든 후 html파일에서 한번만
            link방식으로 호출하면 효율성이 좋아지므로
            @import방식을 더 많이 쓴다~!

            
             */

            /* import방식 CDN 웹폰트 */
            @import url("https://fonts.googleapis.com/css2?family=Hanalei+Fill&family=Kenia&family=Orbitron&family=Rubik+Vinyl&display=swap");

            /* CDN 웹폰트 적용하기 */
            .cdn1 {
                font-family: "Hanalei Fill", cursive;
                color: darkviolet;
                font-weight: normal;
            }

        인라인 요소의 정렬
기본적으로 인라인요소나 글자는 박스의 텍스트정렬로 셋팅한다
인라인 요소의 세로정렬은 일반적으로 line-height를 사용한다!
이미지도 텍스트 정렬이 동일하게 적용됨!
margin: 1000px 50px 0px 80px;
인라인요소의 위아래 마진은 적용되지 않는다! 그래서 1000px은 적용안된다!

box-sizing: border-box;
                - 설정한 박스크기 유지(보더,패딩포함)
                box-sizing: content-box;-> 안줘도 기본값!
                - 설정한 박스크기가 커짐(보더,패딩불포함)
인라인요소에서 float속성은 언제 사용하나?
            - 이미지 옆에 글자가 올 경우 이미지 하단라인에
            단 한줄만 올 수 있게 되어있다.
            이때 글이 이미지 오른쪽/왼쪽에 올라와서 흘러가게
            하고 싶을 경우 사용한다!
            float: left -> 이미지는 왼쪽에 글은 오른쪽에 흘러가라! 
            float: right -> 이미지는 오른쪽에 글은 왼쪽에 흘러가라! 

개별글자색 넣기
.bx요소는 모두 div로 되어있다 div앞에는 h1태그가 형제요소로 있다
따라서 child선택 가상요소를 쓸 수 없다!
왜? h1은 같은 종류의 형제 아니므로! 이럴때는 type선택 가상요소를 사용한다
            (기억해 보세요~! 나보기가 역겨워 가실때에는....)

선택자 해석 예시
    .bx:first-of-type::first-line
    클래스 bx인 요소의 첫번째 같은타입요소를 선택하여
    첫번째줄 가상요소를 디자인 변경하시오!
첫라인 타이틀 만들기 */
         .bx::first-line{

※ 기본적으로 글자크기는 최상위 부모요소로 부터
            하위요소로 상속된다!!!
            -> 브라우저 기본 설정 중 글꼴크기가 중간일때
            16px로 셋팅된다! (기본값을 변경할 수 있고
            기본값이 다를 수 있다!! 주의!! -> "크게"로
            설정되어 있으면 20px이 된다!)

            [ 글자크기 단위 ]

            1. px
            (픽셀단위 - 스크린 픽셀수)

            2. pt
            (포인트단위 - 인쇄잉크 도트개수/인치)

            -> px과 pt의 관계
            브라우저에서 12pt === 16px (이육사)
            -> 1,2이 절대단위

            3. em
            (글자크기의 배수단위:배수의 기준은 부모요소)
            - 기본글자 크기에 따라 1em === 16px, 2em === 32px
            - 만약 기본 글자크기를 변경하면 상대적으로 크기가 변경된다

            4. rem(root em - 배수단위 : 배수의 기준이 root인 html임)

            5. %(퍼센트 단위 : em 배수단위와 유사 100% === 1em)

            - 3,4,5번은 상대단위

            ※ 참고: em 단위의 em은 "엠"으로 발음되고 실제로 "M"문자를
            지칭한다. 활자를 만들때 기본 크기를 "M"문자를 기준한데서
            유래됨

            [ em 또는 rem , % 와 같이 상대단위를 쓰는 이유는? ]

            - 웹 사이트에서 글자크기를 화면에 따라 변경할 경우
            절대단위를 쓰면 모두 하나씩 변경해야 하는 번거로움이 있다!
            (유지보수의 어려움!)

            - 이때 상대 단위를 쓰면 최상위 하나의 절대단위의 크기만
            변경해 주면 모두 상대적으로 그 크기를 변경하게 된다!
            구현과 유지보수의 편리함 때문에 쓰는 것이다!

            [ em 과 rem 의 셋팅상 근본적인 차이! ]

            - html 에서 px을 변경하게 되면 em, rem 모두 변경된다.
            - 그런데 body나 하위 부모 요소의 글자크기를 변경하게되면
            rem으로 셋팅된 부분은 변경되지 않는다!
            왜??? rem은 html의 글자크기를 기준한 단위이기 때문이다!
            - 부모로 부터 상속되는 em, % 는 상대적으로 변경된다!
            - 부분만 변경하고 싶은 경우엔 em 또는 %를 써야할 것이다!

            [ html 글자크기가 자주 10px로 셋팅되어 있는데 이유는? ]
            -> rem 단위 설정시 계산하기 쉽게 하기 위함!

            [ 클래스 다중사용 가이드 ]
                1. 디자인분야별 별도작성된 클래스를 조합할때 사용함
                2. 클래스 다중 사용법은 요소에 클래스속성에
                띄어쓰기로 여러개의 클래스를 적용할 수 있다
                예) <div class="cls1 cls2 cls3"></div>
                3. 클래스를 다중 사용할 경우
                같은 레벨이라면 나중에쓴 클래스가 덮어쓴다
                -> 같은 레벨일 경우 css에서의 코딩위치가 나중인 것이 덮어쓴다!!!

                상위 레벨의 디자인이 있을경우 우선순위를 높이기
                위한 코딩이 필요하다
                - 상위레벨 요소 선택자를 같이 쓰는 경우 순위가 올라감

                -> 프로젝트나 프레임워크 또는 css솔루션 소스에서
                다중 클래스 적용은 굉장히 흔한 코딩법이다!
                -> 분리된 CSS 소스코딩이 깔끔한 코딩법의 비결이된다!

                [ 일반적인 CSS 우선순위! ]
                
                !important > inline > id > class > type

                -> 같은 레벨에서 부모요소를 쓴것이 우선함!
[ 스프라이츠(Sprites) 기법 ]

                - 하나의 이미지로 배경 이미지 처리하여
                배경 이미지의 위치값을 변경함으로 각각의
                이미지를 표현하는 기법

                - 이점:
                    1) 이미지 용량을 줄임
                    2) http Request(웹요청)가 줄어들어
                        웹 페이지의 랜더링 속도가 빨라진다!

                - 대부분 모바일에서 용량 및 속도 이슈가 있으므로
                스프라이츠 기법을 사용함!

                - 요즘은 DT(데스크탑)에서도 많이 사용되고 있다

                ______________________________________

                [ 스프라이츠 배경 이미지 위치알아내기 ]

                1. MS 그림판으로 스프라이츠용 이미지를 열고
                마우스 포인터를 그림위에 움직이면 x,y축 순서로
                픽셀정보가 보임-> 왼쪽하단 (포토샵도 가능)

                2. 이렇게 얻어낸 정보로 배경위치값으로 
                마이너스 픽셀값 설정을 하면 선택요소에 
                배경이미지의 원하는 부분이 보인다!

                예) background-position: -551px -429px;

                3. 이미지 크기는 그림판의 선택툴로 크기를 잡고
                하단에 보면 크기정보가 표시된다!

                4. 만약 이미지가 원본 배경 보다 작게 사용한다면
                위치, 크기가 달라지므로 그림판의 "크기조정" 메뉴로 비율을 유지하며 가로크기를 원하는 만큼
                조정하여 적용후 위치와 크기를 측정한다!
[ 이미지를 사용할때 웹접근성 이슈 ]
                
                - 이미지 태그를 사용하여 코딩시 
                alt속성을 이용하여 이미지에 대한 설명을
                제공한다(필수사항! 법제화되어 있음) 

                - 배경이미지로 표현할 경우 설명은
                어디에 써서 접근성이슈를 해결할 것인가?
                
                - 웹접근성 참고(웹접근성 연구소)
                https://www.wah.or.kr:444/Participation/technique.asp
[ IR(Image Replacement) 기법 ]

                - 이미지를 배경처리하였을때 이미지에 대한
                설명(alt)을 넣을 수 없는데 이는 접근성에
                위배된다. 따라서 span태그를 쓰고 이미지
                설명을 표시한 후 이를 숨겨서 설명을 제공
                하는 것이 IR기법이다!

                - 웹접근성은 웹에서 정보제공에 대한 평등성을 말한다!

                - Sprites 기법을 사용할때 IR기법을 같이 사용한다!

                [ 크롬 브라우저 스크린 리더기를 
                확장프로그램에서 설치한다! ]
                ChromeVox Classic Extension

    [ 뷰포트 단위란? ]

            - 먼저 뷰포트란 무엇인가?
            : 디바이스(화면을 가진 기기)의 보이는 화면의 
            접점을 이른다
            - 뷰포트 단위란 무엇인가?
            : 보이는 화면을 기준한 %단위로 크기를 정하는 것!

            - 그렇다면 %단위와의 차이는 무엇인가?
            : %는 일반적으로 부모크기를 기준으로 자식요소의
            크기를 정하거나 폰트일 경우 상속받은 부모폰트를 기준한
            상대적인 크기를 말한다.

            : 반면 뷰포트 단위는 [무조건 보이는 화면을 기준한다!!!]
            -> 보이는 화면에 대한 %비율을 말한다!!!
            (글자크기, 박스크기 등에 동일하게 적용된다!)

            ___________________________________________________

            [ 뷰포트 단위의 종류 ]

            1. vw (viewport width)
            - 화면의 가로크기를 기준한 %비율(0~100)

            2. vh (viewport height)
            - 화면의 세로크기를 기준한 %비율(0~100)

            3. vmax (viewport maximum)
            - 화면의 가로,세로크기 중 큰 사이즈를 기준한 %비율(0~100)

            4. vmin (viewport minimum)
            - 화면의 가로,세로크기 중 작은 사이즈를 기준한 %비율(0~100)

            -> vmax / vmin 은 가로폭 또는 세로폭이 너무 작거나 커질때
            그 크기를 유지 하고자할때 주로 사용한다!

            ______________________________________________

            [ 뷰포트의 기준인 보이는 화면이란? ]

            - 스크롤바 트랙까지 다 포함하는 보이는 화면을 말한다!
            왜냐하면 모바일화면을 기준한 단위이기때문에 모바일에서는
            스크롤바트랙이 자리를 차지하지 않기때문이다!
            - 데스크탑 브라우저에서 주의요망!!!

            _____________________________________________

            [ 뷰포트 단위는 언제쓰나? ]

            - 이미지로 글자를 쓰지 않고 폰트를 사용한 경우
            화면크기에 따라 유동적인 크기를 가져야할때
            - 화면을 기준한 박스크기를 설정해야할 경우

            ____________________________________________

            [ 뷰포트의 장점 ]

            1. 미디어쿼리를 사용하지 않고 크기를 화면에 맞춰조정가능
            2. 반응형 디자인에 최적화된 단위임(특히 모바일에!)

            ______________________________________________

            [ 뷰포트의 단점 ]

            1. 부모요소의 크기를 기준할 때는 사용하기 어려움
            2. 화면의 비율이 가로, 세로로 다변화할때 판단하기 어려움
            3. 요소간 상대적인 디자인이 아닐 경우 어려움이 있음

            ※ 유의사항: 
            뷰포트 단위는 메타태그의 viewport와 상관없다!
            (메타태그 뷰포트를 꼭 사용해야하는 것은 아니다라는말!)

    min(값들) 
                -> 값들 중 작은값 출력
                -> 값들은 보통 
                (유동적크기,정해진크기)
                -> 결과적으로 최대사이즈 지정!
max(값들) 
                -> 값들 중 큰값 출력
                -> 값들은 보통 
                (유동적크기,정해진크기)
                -> 결과적으로 최소사이즈 지정!
max(min(10vw, 100px),50px);
            /* min과 max 를 중첩하여 내부에서는
            최소사이즈체크, 외부에서는 최대사이즈체크 */
100vw는 스크롤바 트랙을 무시!
            보이는 화면은 트랙을 포함한 영역으로 표시
            -> 모바일화면개념이다!
            -> 사용: 모바일화면/스크롤바가 없는 DT
100%는 스크롤바 트랙을 존중!
            -> 스크롤바 트랙을 뺀 화면전체가 100%임!
            -> 사용: 스크롤바가 있는 DT 

    [ li박스를 옆으로 보내기 위한 2가지방법 ]

            1. float:left
            2. display: inline-block
            -> 보통 1번을 많이 쓰는데 왜일까?
            답: 엔터간극때문!
            (엄밀한 디자인, 가독성코드 때문)
            -> 엔터사이에 주석을 넣으면
            엔터가 없는 것으로 인식하지만
            너무 불편하다~~~~!

            [ inline-block 의 특징 ]
            1) 인라인요소 처럼 옆으로 배열이됨
            2) 블록요소 처럼 크기 등의 디자인이 적용됨
            3) 가독성있는 코딩을 원할 경우
            엔터를 치면 사이에 간극이 생김(엔터간극)

            - 엔터간극 없애는법
            -> 엔터를 치지 않으면 됨
            -> 엔터부분에 주석을 넣음
            
            4) 인라인블록 출신요소가 있음!
                -> button, input

        /* 
            [ CSS Clipping ]
            - 이미지의 일부영역을 지정하여 부분만 보이게하는
             display기법
        */
        /* 1. 정원클리핑 
            clip-path: circle(반지름 at x좌표 y좌표);
            -> 소괄호안의 값을 안쓰면 이미지를 채우는 중심원이 나옴
        */
        .clip-circle{
            /* clip-path: circle(116px at 125px 137px); */
            clip-path: circle(50% at 50% 50%);
        }
        /* 2. 타원클리핑 
            clip-path: ellipse(가로축 세로축 at x좌표 y좌표)
            -> 소괄호안의 값을 안쓰면 이미지를 채우는 타원이 나옴
        */
        .clip-ellipse{
            /* clip-path: ellipse(186px 79px at 188px); */
            clip-path: ellipse(51% 30% at 52% 50%);
        }
        /* 3. 다각형클리핑 
            clip-path: polygon(x1 y1,x2 y2,...)
            -> 소괄호안을 비울 수 없다!
            -> 각 좌표값은 px,%모두 가능
        */
        .clip-polygon{
            clip-path: polygon(62% 1%, 73% 0%, 78% 21%, 77% 24%,68% 20%, 65% 27%,65% 38%, 64% 31%,74% 49%,73% 70%,64% 85%,52% 87%,36% 84%,0% 58%,33% 44%,50% 41%,51% 29%, 53% 21%,59% 7%);
        }

        /* 4. svg클리핑 
            clip-path: url(#아이디명)
            - 미리 만들어진 아이디명의 svg 요소를 지정하여 
            그 모양만큼만 이미지가 보임
        */
        .clip-svg{
           clip-path: url(#myClip);
        }

        /* 
            [ CSS Masking ] - 아직 웹표준기술아님!
            - 이미지의 일부를 자연스럽게 감추는 기법
            - 검정색부분은 보이는 영역, 투명색은 숨기는 영역
            - 셋팅법이 배경이미지 셋팅과 유사
            linear-gradient와 같은 그라데이션
            CSS함수를 이용하여 셋팅함
        */
        .masking1{
            -webkit-mask-image: linear-gradient(to right, black 30%, transparent 80%);

        }

    [ CSS 적용 우선순위 ]
    type < class < id < inline < !important

    -> 더 쎈 선택자이여도 부모요소를 업고 
    있는 것이 더 쎄다!
    예) #my < .cont .my

★[[ JavaScript에서 요소의 위치 구하기]]★

    [ offsetTop / offsetLeft] 
    -> 부모자격요소를 기준한 위치값
    -> 제이쿼리 position()과 같음

    [ getBoundingClientRect() > top / left ] 
    -> 스크롤위치를 뺀 화면 기준
    -> 제이쿼리의 offset() 과 같은 절대값을 구하려면
    스크롤위치값을 본 값에 더해야함!
    -> 주로 세로 스크롤을 사용하므로 top값에 스크롤값을 더함
    예) 요소.getBoundingClientRect().top + window.scrollY

    ※ 참고: 바운딩 값은 소수점 아래 많은 자릿수까지 표시하므로
        이것을 소수점자리 제한하여 사용할 수 있다!
        -> toFiexd(자릿수) : 자릿수에 0을 넣으면 소수점 아래버림
    ___________________________________________________________

    ★[[ JavaScript에서 요소의 크기 구하기 ]]★
    
    -> 한눈에 보기:
    http://jsfiddle.net/y8Y32/25/
    
    [ 가로크기 ]
    - clientWidth : 패딩점퍼를 입고 있는 클라이언트님!
        padding을 포함한 폭
    - scrollWidth :  가로스크롤내용이 들어가니까 scroll!
        padding을 포함한 화면 상에 표시되지 않은 콘텐츠를 포함한 폭
    - offsetWidth : 보더,패딩,세로스크롤바 트랙이 다 들어가니 옵셋!
        border, padding, 세로스크롤바 트랙을 포함한 폭
    
    [ 세로크기 ]
    - clientHeight : 패딩점퍼를 입고 있는 클라이언트님!
        padding을 포함한 높이
    - scrollHeight :  세로스크롤내용이 들어가니까 scroll!
        padding을 포함한 화면 상에 표시되지 않은 콘텐츠를 포함한 높이
    - offsetHeight : 보더,패딩,가로스크롤바 트랙이 다 들어가니 옵셋!
        border, padding, 가로스크롤바 트랙을 포함한 높이
    _____________________________________________________________

    ★[[ 윈도우 사이즈 가져오기 ]]★
    window.innerWidth :  스크롤 바를 포함하지 않는 창 너비
    window.innerHeight : 스크롤 바를 포함하지 않은 창 높이
    window.outerWidth : 스크롤 바를 포함, 창의 너비
    window.outerHeight :  스크롤 바를 포함한  창의 높이
    _____________________________________________________________

    ★[[ 현재 스크롤바 위치값 가져오기 ]]★
    1. window.scrollY (IE6~11지원안함)
    2. document.scrollingElement.scrollTop
    3. document.documentElement.scrollTop
    4. document.querySelector('html').scrollTop

    _____________________________________________________________

    ★[[ 이벤트발생시 위치값 ]]★
    1. clientX, clientY
        -> 현재 보이는 브라우저 화면이 기준

    2. offsetX, offsetY
        -> 이벤트 대상이 기준

    3. pageX, pageY
        -> 전체 문서를 기준(스크롤 화면을 포함)

    4. screenX, screenY
        -> 모니터 화면을 기준
// .inbox하위 .bird(벌새)위에서 마우스움직일때
    // 이벤트 버블링으로 offsetX,offsetY는 이벤트 대상의
    // 위치를 리턴하므로 벌새값이 .inbox이벤트찍기에 나타남!
    // .bird의 같은 이벤트를 버블링막기를 하면
    // 벌새위에서는 이벤트가 발생하지 않는다!(버블링되지 않는다!)

    // 이벤트버블링 막기를 할 수 있다~!
    // bird.onmousemove = (e)=>{
    //     e.stopPropagation();
    // }; /////// mousemove ///////

[ import 형식 ]
    import 전달변수 from 파일경로;
    -> 반드시 가져올 모듈JS에서 export를 해줘야함!
    -> from 뒤에 경로는 반드시 상대경로일 경우
    같은 위치일 지라도 ./ 표시를 꼭해야함!(없으면 안나옴!)
    (/,./,../ 표시필수)
    -> 모듈구성은 반드시 서버형식으로 열어야 작동한다!
    (http://...) Live Server로 열기때문에 볼 수 있음!
    -> 로컬파일로 열면 작동안됨!

    [ import 시 변수명 변경하기 : 별칭사용하기 ]
    import {전달변수 as 별칭} from 파일경로;
    예) import {mymymy as m} from 파일경로;
    -> 별칭 사용이유:  단순변경요구, 같은이름 변수 피하기

    ____________________________________________________

    [ 모듈화를 위한 구성 ]
    1. 데이터 처리하기 위한 JS
    -> text_data.js
    2. 구체적인 데이터 구성처리를 위한 JS
    -> msgFormat.js

<script type="module" src="./module/main.js"></script>
스크립트 호출 시에 type="module"이라고 써야 모듈화 문법인
        import를 사용할 수 있다.
        (예전에는 type='text/javascript'라고 썼었음)
        그리고 동시에 자동으로 defer가 세팅 된다.
        -> html요소가 모두 로딩 후 실행 됨!

[ 웹 페이지간 데이터 전달방식 ]
- 원래 html의 기본특성은 "비연결성"이다.
즉, 한번 요청된 페이지는 스스로 업데이트 되지 않는다!
페이지 간 데이터를 전달하는 방식이 요구되어짐.

1. Get 방식 : url뒤에 ?(물음표) 뒤에 (키=값) 쌍으로
데이터를 전달하는 방식(이 방식은 페이지셋팅에 적합하다!)

2. Post 방식 : 페이지 내부에 form태그로 감싸서
데이터를 입력받고 페이지에 숨겨서 다른 페이지로
전송하는 방식
(포스트방식은 편지처럼 봉투안에 숨겨져서 보내지는 것과 유사!)
-> 회원가입, 로그인 등 민감한 데이터를 전송할때 적합하다!

(참고로 Get방식은 3000byte 까지 데이터 전송이 가능하며
Post방식은 데이터 크기에 제한이 없다!)

[ Get방식으로 다른 페이지에 data전달하기 ]
1. url뒤에 데이터를 (키=값) 쌍으로 전달
2. 형식: url?키=값&키=값&...
3. ?(물음표)는 Get방식으로 데이터를 넘긴다는 시그널한 
    url에는 단 하나의 물음표만 허용됨!!!!
4. &(엔퍼센드)는 키=값 쌍단위를 구분해주는 구분자

[ url로 보낼때 한글깨짐 방지하기! ]

    2byte문자(한글,일본어,한자,아랍어 등)를 url로 보내면 규칙성 없이 깨져서 전달된다!
    따라서 규칙성 있게 변환하여 보내고 받는 페이지에서 그 규칙을 풀어서 복원한다!

    1) 보낼때: encodeURIComponent(값) - 2byte문자를 변환하여 보냄
    2) 받을때: decodeURIComponent(값) - 2byte문자를 변환하여 받음(복원)

    -> 참고로 encodeURIComponent변환은 암호화가 아니다!
    변환하는 규칙이 있고 잘 보면 읽을 수 있다!

    엔코딩 표준에 따라 모든문자는 16진수 2 디짓(%xx)이나 4 디짓(%uxxxx) 데이터로 전환된다.
     예를 들어 빈칸(' ')은 %20, 세미콜론(;)은 %3B, '한글'은 %uD55C%uAE00'이 된다.

    -> 참고) encodeURI(), decodeURI() => 전체 URL처리시 사용!
    -> 주의) 최신브라우저에서 encodeURIComponent()를 안해도 자동 인코딩처리를 해주는데
    모든 브라우저에 지원되지 않는 점을 고려해서 encodeURIComponent()처리를 해주는게 정석이다.

[ 팝업창 띄우기 ]
            if(gubun){
                url = 'https://www.w3schools.com/';
            }else{
                url = 'popwin.html'
            } ///////////if else //////////////
            window.open(url,'_blank','width=600,height=500,top=200,left=200');

            // window.open(이동창주소,창이름/창형식,옵션)
옵션없이 url만 사용하면 새창(새탭)으로 뜸
- 익스는 최신엣지가 아닌 이전 익스임!
        
            1. 툴바출력여부(yes/no 또는 1/0) - 익스용
            toolbar=yes/no 
            2. 스크롤바여부 - 익스용
            scrollbars=yes/no
            3. 창크기조절여부 - 익스용
            resizable=yes/no
            4. top위치값 - 공용
            top=숫자(px)
            5. left위치값 - 공용
            left=숫자(px)
            6. 폭 - 공용
            width=숫자(px)
            7. 높이 - 공용
            height=숫자(px)

    [ 콜백함수란?  "나중에 다시 호출할께!"]

    콜백은 다른 함수에 인수로 전달되는 함수다.
    이 방법을 사용하면 함수가 다른 함수를 호출할 수 있다.
    다른 함수가 완료된 후 콜백 함수를 실행할 수 있다.

    ______________________________________

    [ 콜백은 언제 사용하나?]

    콜백이 정말 빛을 발하는 곳은 하나의 함수가 
    다른 함수를 기다려야 하는 비동기 함수다!(예: 파일 로드 대기).
    비동기 함수는 2번 async.html에서 연습한다!

    [ 비동기 호출이란? ]
        "나중에 끝낼께!"

    다른 함수와 병렬 로 실행되는 함수를 비동기 라고 한다.
    좋은 예는 자바스크립트 내장함수인 setTimeout() / setInterval()이다.
    _______________________________________________________________

    [ 콜백 대안 ]
    비동기 프로그래밍을 통해 JavaScript 프로그램은 장기 실행 작업을 시작하고 
    병렬로 다른 작업을 계속 실행할 수 있다.

    그러나 비동기 프로그램은 작성하기 어렵고 디버깅하기 어렵다!!!

    이 때문에 대부분의 최신 비동기 JavaScript 메서드는 콜백을 사용하지 않음! 
    대신 JavaScript에서 비동기 프로그래밍은 Promise를 대신 사용하여 해결됨!

    [프라미스(Promise)란? "원하는 결과를 보장해! 약속해!"]

    "생성코드"는 시간이 걸릴 수 있는 코드이다.
    "사용코드"는 결과를 기다려야 하는 코드이다.
    Promise는 생성 코드와 사용코드를 연결하는 JavaScript 객체다!
    __________________________________________________________

    ((구문))
    let 약속변수 = new Promise(function(성공함수, 실패함수) {
    // 생성코드 : 시간이 걸리는 코드

    성공함수(리턴값사용가능); // 성공시호출
    실패함수(리턴값사용가능);  // 에러시 호출
    });

    // 사용코드 : 약속객체가 완료될때까지 기다림!!!
    약속변수.then(
    function(변수) { 성공시코드 },
    function(변수) { 실패시코드 }
    );

    ________________________________________

    [ AJAX 비동기 파일처리 전송객체 ]
    AJAX (Asynchronous Javascript And XML)

    -> XMLHttpRequest객체

    1. 특징:
        (1) 웹서버의 데이터 읽기(페이지로드후)
        (2) 페이지로 리로드하지 않고 웹페이지를
            부분업데이트함
        (3) 백그라운드 웹서버로 데이터 전송기능

    2. 사용법:
        (1) 인스턴스를 생성하여 변수에 할당하여 사용
            예) let ajax = new XMLHttpRequest();

        (2) 인스턴스를 열어서 전송준비를 한다
        -> open(방식,요청URL,아이디,비번,비동기옵션)
        -> 핵심: open(방식,요소URL)
            1) 방식: GET/POST -> GET방식을 더 선호함
                이유는 가볍고 빠르게 처리함
                POST방식은 민감한 데이터 처리시 사용!
            2)  요청URL : 
                웹서버의 페이지나 파일경로주소
            3) 아이디/비번 : 
                웹서버 접근시 인증이 필요한 경우 사용함
            4) 비동기옵션 : 기본값 true -> 비동기처리
                -> 아무것도 안쓰면 true로 비동기처리됨!
                만약 false라고 하면 동기적처리를 함!
                -> 비동기적으로 처리해야 페이지가
                멈추지 않고 요청파일만 별도로 처리한다!
            예) ajax.open("GET","https://my.com/my.pdf")

        (3) 비동기전송 후 처리를 위한 로드함수구역 만들기 (onload:서버요청 기다림 요청오면 실행)
        -> 
        인스턴스변수.onload = function(){처리소스};

        -> 여기서 onload라는 것은 서버에서 결과를 로드한다는 의미임!
        -> 결과처리 상태값은  : 
            인스턴스변수.status 값으로 한다!

            [ status 결과상태종류 ]
                1) 200 : "OK" - 처리완료됨
                2) 403 : "Forbidden" - 파일접근거부
                3) 404 : "Not Found" - 파일없음
                -> statusText 로 받으면 위의 문자형으로 리턴한다!

            [ response 결과내용 종류 ]
                1) responseText : 데이터를 문자형식 받기
                2) responseXML : 데이터를 XML형식 받기
                3) responseURL : 데이터 전송 URL 받기

        (4) 오픈 셋팅된 요청객체를 전송한다!
            인스턴스변수.send()
            -> open() -> onload -> send() 순으로 코딩

        [ 웹서버 파일 요청시 주의사항! ]
        1. 요청한 파일이 현재 페이지의 도메인주소와
        다른경우 (이종도메인) XSS공격 등의 이유로
        브라우저에서 이것을 금지하고 있다!
        (일반 XMLHttpRequsest 요청으로 가져오기는
        가능함!)

        2. Promise를 사용하여 파일을 요청하고
        에러발생시 이것을 실패함수로 처리할때
        이종도메인 에러는 Promise의 에러도 발생시키므로
        실패함수처리가 되지 않는다!!!

        3. 이것은 근본적인 브라우저 정책이므로
        해결방법은 같은 도메인의 파일을 요청하는 것이다! (외부도메인 파일을 같은 서버에 저장하여 사용하는 경우가 많다!)

    [ Async/Await란? "약속을 좀 더 쉽게!"]

    1. async는 함수가 Promise를 반환하도록 설정한다!
    2. await는 함수가 Promise를 기다리게 설정한다!

    [ async 구문 사용법 ]
    ___________________________________

    -> 함수앞에 async 키워드를 써준다!
    ___________________________________

    async function 내함수() {
        return "우리지금만나!";
    }
    ____________________________________

    -> 위의 코드는 아래의 코드와 동일하다!
    ____________________________________

    function 내함수() {
        return Promise.resolve("우리지금만나!");
    }
    _______________________________________________________

    -> async키워드를 사용한 함수호출코드 뒤에 
    .then을 사용하여
        성공시/실패시코드를 작성한다!
    _______________________________________________________

    내함수().then(
        function(value) { 성공시코드 },
        function(error) { 실패시코드 }
    );
    ____________________________________
    *********************
    [ await 구문 사용법 ]
    ___________________________________

    -> await키워드는 
        async함수 내에서만 사용가능함.
    -> await키워드 는 
        함수실행을 일시 중지하고 계속하기 
        전에 Promise의 결과를 기다림
    ___________________________________

    async function 보여줘() {
    let 내약속 = new Promise(function(성공함수) {
            성공함수("내메세지");
        });
        document.getElementById("mydiv").innerHTML = await 내약속;
    }

    보여줘();
    ___________________________________

    ((단어뜻))
    * resolve 해결하다
    * asynchronous 동시에 존재하지 않는
    * await 기다리다


    [ 제이슨 파일 내부형식에 관하여... ]

    1. 제이슨 파일은 내부형식이 객체형식이지만
    자바스크립트에서 속성명을 변수형으로 쓰는 것처럼
    사용할 수 없다! 반드시 쌍따옴표로 싸서 문자형으로
    표현해야만 한다!

    2. 제이슨 파일 내부에 JS주석문은 쓸 수 없다!
    (vscode의 settings.json에서 주석문은 vscode에서
    별도의 처리를 하므로 사용가능했던것임...)

    3. 제이슨은 최상위 형식으로 객체/배열로써 하나만 존재할 수 있다!
        예) {속성명:값,...} / [{속성명:값,...},{속성명:값,...}]

    4. 제이슨 맨 마지막 항목 뒤에 콤마를 남길 수 없다!(에러!)
    -> 자바스크립트에서는 마지막콤마 허용함!

    [ await 사용시 주의사항! ]
    await에서 프라미스 인스턴스를 변수에 담지 않고 사용하면 Pending처리(보류처리) 된 인스턴스가 전달되는 경우가 생긴다!

    따라서 변수에 await 프라미스 인스턴스를 담아서 그 리턴값을 확정한 후
    (변수할당이란 값을 특정주소지에 넣고 사용할 준비를 하는것!)
    그 값으로 함수를 다시 호출하던지 후속코드 작업을 하면 된다!
    -> await를 담은 변수에 값이 할당되기전엔 그 값을 이용하는 코드도 모두 대기상태다!!!


    [ fetch 프라미스 ]
    데이터를 다른 서버에서 가져올 경우 같은 서버에 위치한 파일보다 시간이 더 걸릴 수 있다!
    이 때 그 전송파일을 이용한 처리코드가 에러를 나타낼 확률이 높아진다.
    이때 Promise를 사용하면 되겠다.
    더 쉬운 Promise가 fetch API 이다.
    https://www.w3schools.com/js/js_api_fetch.asp

    [ fetch API란 ]
    Fetch API 인터페이스를 사용하면 웹 브라우저가 웹 서버에 HTTP 요청을 할 수 있습니다.
    😀 더 이상 XMLHttpRequest가 필요하지 않습니다.

    1) 사용법 : 
    변수 = 웹상파일주소;

    fetch(변수)         // 웹 브라우저 데이터 로드
    .then(              // 로드 후 실행구역
        x=>x.text()     // 텍스트 읽기
        )
    .then(              // 텍스트 읽은 후 실행구역
        y=>명령어 사용   // 텍스트 읽기
    )

    2) 사용법 : 
    변수 = 웹상파일주소;

    // async 함수 만들기
    async function 비동기함수(변수){
        변수1 = await fetch(변수);  //fetch기다림
        변수2 = await 변수1.text(); //text()기다림
        하고싶은 코드... // 위의 코드 완료 후 실행
    } /////// 비동기함수 ///////

    // 적절한 곳에서 비동기함수 호출
    비동기함수(변수);


[ Javascript란? ]
            
    - 고정적인 html 구조와 CSS로 디자인 된 웹문서의
    디자인 혹은 기능적으로 구현 된 것을 변경하기 위해
    개발 된 브라우저 전용 프로그래밍 언어다!

    _________________________________________

    [ JS의 코딩구역 ]

    1. 이터널(internal)방식
    - html의 script 요소 내부에 데이터로 코딩함
    (스크립트 사이에 들어가는 내용을 데이터라고 말함)

    2. 익스터널(external)방식
    - JS 외부 파일로 확장자가 .js
    - html 페이지에서 script요소에 src속성의 값으로
    파일 위치를 지정하여 호출함!
    예) <script src="파일경로/이름.js">

    3. 이벤트 속성의 인라인(inline)코딩
    - html은 요소마다 이벤트 속성 값으로 JS코드를 작성함
    예) <h1 onclick="JS코드">

    _________________________________________

    [ JS의 역할 ]

    1. html을 변경

    2. CSS의 디자인 속성을 재정의 한다.
    (디자인 속성은 이미 기본값이 다 존재하기 때문에
    재정의라고 함)

    [ 각 언어별 역할 비유 ]

    1. HTML(구조) - 건물의 콘크리트 구조물

    2. CSS(디자인) - 건물의 인테리어, 익스테리어

    3. JS(프로그래밍) - 건물의 수도, 전기, 엘리베이터 등

    ___________________________________________

    [ JS의 화면 출력 ]

    1. document.write(내용) - html화면 상단에 출력
    2. window.alert(내용) - 팝업형식의 경고창으로 출력
        ->window를 생략 가능 : alert(내용)
        ->html이 랜더링 되기 전에 제어권을 가짐!
    3. console.log(내용) - 콘솔창에 출력
        ->개발 시에 많이 사용함
        ->콘솔:브라우저 엔진에서 관할하는 내부출력모드
        ->개발자모드(F12)의 콘솔(console)탭을 선택함
        ->콘솔창에 로그가 찍힌 라인번호를 알려준다!

    ____________________________________________

    [ JS 코드의 특징 ]

    1. JS 명령어 실행코드는 만나는 즉시 실행됨!
    그래서 내가 원하는 시점의 이벤트가 명령어코드가
    실행되려면 함수가 필요하다.

    _____________________________________________
    
    [ JS의 함수 ]
    - 정의 : 특정실행코드를 특정이벤트에 실행하도록
    호출 시에만 코드를 실행하는 코드저장공간!

    - 형식 : function 함수명(전달변수){코드}

    - 호출 : 함수명(값)
    -> 값은 함수의 전달 변수 개수만큼 보낸다!

    _____________________________________________

        [ JS의 이벤트란? ]
    - 브라우저에서 실행되는 입력 또는 상태변경
    관련 시점을 구분하여 알려주는 요소

    - 이벤트의 종류:
    1) 마우스 관련 이벤트
    - click, dblclick, mouseover, mouseout, mouseup,...
    2) 키보드 관련 이벤트
    - keydown, keyup, keypress,...
    3) 기타 이벤트
    - load, focus, blur, ...

    -> 이벤트와 함수를 연결하려면?
    html 요소에 이벤트 속성 모두 만들어져 있다!!!

    [ HTML 이벤트 속성 ]

    -> on+이벤트명 = 값
    예) <h1 onclick="함수명()">
        onmouseover="값", onload="값"
    
    _____________________________________________

    [ JS의 이퀄의 의미 ]
    - 이퀄은 오른쪽 값이 왼쪽에 할당됨을 의미
    (할당은 값이 특정 메모리공간에 들어감을 의미)
    -> 절대로 같음의 의미가 아님

    [ JS의 점(.)의 의미 ]
    - 객체의 하위 메서드나 속성으로 들어감을 의미
    - 객체는 목적을 가지고 만든 프로그램 단위체
    - 메서드는 객체 내부에 만들어진 함수(코드저장소)
    - 속성은 객체 내부의 특정 값을 정의하는 항목

    예) 우주.우리은하.태양계.지구.대한민국.서울.강남구

    _______________________________________________

    [ JS에서 코드의 마무리는 세미콜론 ;;;;; ]

    - JS의 코드 끝에는 세미콜론으로 마무리 한다!
    - 세미콜론이 안붙는 경우
        1) 선언적 함수(이름이 있는 함수)의 끝
        2) 제어문(if문, for문,...)의 끝

    ((참고: 자동세미콜론 삽입기능))
    ASI(Automatic Semicolon Insertion)
    -> 브라우저가 세미콜론이 필요한 부분의 구문분석을
    통하여 자동으로 넣어주는 기능!
    -> 주의사항: 세미콜론을 안써도 되는 편리한 기능이지만
    자동구문분석에서 오류분석이 있을 수 있으므로
    개발자가 직접 세미콘론을 넣어주는 것을 추천함!!!

    ______________________________________________

    [ JS의 따옴표의 의미 ]

    - 문자값을 의미 (String:문자데이터)
    - 문자를 따옴표로 안싸면 그것은 변수라고 함!

    ______________________________________________

    [ JS에서 요소를 선택하는 방법 ]

    - document 객체 : 
        html문서 전체를 담고 있는 DOM객체
    
    - DOM(document Object Model)
        : 웹문서에 있는 각 요소로 접근할 수 있는 방법을
        제공하는 언어중립적 인터페이스다.
        (인터페이스:소통이 이루어지는 장소의 수단과 방법)

    ______________________________________________

    [ JS기본 요소 선택법 ]

    1. 아이디 선택법 :
        getElementById(아이디명)
    가져와 요소를 아이디로!
    -> 아이디는 유일, 선택 즉시 접근가능함

    2. 클래스 선택법 : 
        getElementsByClassName(클래스명)
    가져와 요소들을 클래스명으로! 
    
    -> 클래스는 여러번 사용 가능하므로
    선택 후 순번을 반드시 선택해야 구체적인 요소에 접근가능
    -> 순번 선택방법 : item(순번) / [순번] 
        document.getElementsByClassName(클래스명).item(순번)
        document.getElementsByClassName(클래스명)[순번]

    3. 태그 선택법 : 
        getElementsByTagName(태그명)
    가져와 요소들을 태그명으로! 
    
    -> 태그는 여러번 사용 가능하므로
    선택 후 순번을 반드시 선택해야 구체적인 요소에 접근가능
    -> 순번 선택방법 : item(순번) / [순번] 
        document.getElementsByTagName(태그명).item(순번)
        document.getElementsByTagName(태그명)[순번]
    
    ______________________________________________


        [ JS에서 요소 선택 후 CSS변경하기 ]

    1. 스타일 시트 속성명으로 개별 추가하기

    선택요소.style.스타일시트속성명 = 속성값
    - 선택요소의 CSS특정 속성값을 변경함
    - 스타일시트 속성명은 모두 변수형으로 JS브라우저
    객체의 속성으로 만들어져 있다!

    예) 'font-size' -> fontSize
        'border-radius' -> borderRadius

        -> 이음절 이상 속성명은 데쉬(-)를 빼고
        단어 첫글자를 대문자로 처리하여 사용함!

        -> JS에서 CSS를 변경하면 요소 태그 내부에
        style속성으로 인라인코딩 되어 들어간다!
        (최우선 적용!)
    
    2. 한꺼번에 style속성값으로 넣기
    -> style.cssText = 'css문법'
    -> 이전에 코딩 된 인라인 style속성값은 무시됨
    -> 백틱(`)을 사용하면 좀 더 가독성 있는 코딩 가능
    ______________________________________________

        [ 선택자 문법을 그대로 선택하는 요소 선택법 ]
    
        1. querySelector(CSS선택자)
    -> 선택자에 맞는 요소를 처음 만나는 것으로 선택
    -> 무조건 하나만 가져오므로 순번 필요 없음
    
    예) document.querySelector('#my>li')
    -> 만나는 첫번째 li요소를 선택함

    2. querySelectorAll(CSS선택자)
    -> 선택자에 맞는 요소를 모두 가져옴
    -> html요소 컬렉션에 담겨서 저장됨
    -> 순번과 개수를 구할 수 있음
    순번 : item(순번) / [순번]
    개수 : length

    예) document.querySelectorAll('#my>li')
    -> 만나는 li모두를 선택함!(순번, 개수 사용함!)

[ JS의 변수란? ]
    _______________
    
    1. 정의:
    다양한 형태의 데이터를 저장할 수 있는 메모리 공간

    - 메모리의 특정위치는 주소의 변수명이다!
    - 브라우저 어플리케이션 할당 디스크에 저장됨
    - 개념적으로 그릇과 유사하다. 담는 것에 따라 달라짐
    (밥을 담으면 밥그릇, 국을 담으면 국그릇)

    ____________________________________________

    2. 변수의 위치

    - 변수는 이퀄 왼쪽에 온다.(데이터는 오른쪽에)
    변수 = 데이터 (데이터가 변수에 담긴다)
    _____________________________________________

    3. 변수의 선언 : var 변수명

    - 변수는 반드시 문자로쓴다
    - 변수는 따옴표로 싸지 않는다
    (싸면 문자 데이터)
    - 하나의 변수 명은 띄어쓰기를 하지 않음

    예) var myName
    -> var는 Variable 에서 나온 말
    
    알림! 최근 JS는 ES6버전의 let, cont를 씀!
    -> JS2-2. 바렛콘스트.html 에서 상술함!

        ______________________________________

        4. 변수의 명명법(Naming Rule)

        - 변수의 띄어쓰기를 못하고 모두 붙여서
        한단어처럼 작성한다!

        - 2음절 이상의 단어를 변수로 만들때
        아래 규칙으로 작성함!

        (1) 캐믈 케이스(Camel Case)
            첫단어는 소문자
            뒷단어는 첫글자 대문자
            예) myHouseIsBig

        (2) 파스칼 케이스(Pacal Case)
            모든 단어 첫글자 대문자
            예) YouAreMyLover

        (3) 스네이크 케이스(Snake Case)
            단어사이에 언더바(_)사용
            예) seoul_korea_good   
            
        -> 변수명 작성시 주의사항:
            첫문자를 숫자나 특수문자를 쓰지 말것!
        -> 변수는 대소문자를 철저히 구분함
        예)House, hOuse, hoUse, houSe, housE
        ->> 단어가 같지만 대소문자가 다른면 모두다른변수

        ________________________________

        5. 변수의 할당
        - 선언된 변수에 값(데이터)을 넣는것!
        - 변수는 왼쪽, 값은 오른쪽
        예)
        var my_house_is_big = '얼마나 큰데?';

        - 할당시 규칙:
            -- 한 문서안에 같은 이름의 변수를 한번만 씀
            -- 단, 지역/전역변수에 따라 같은이름 존재가능!
    _________________________________________

    6. 데이터 종류

    (1) 문자형 : "나비", '사람', "100"
        - 따옴표로 싼 모든 문자데이터
    
    (2) 숫자형 : 1,2,3,4.5
        - 따옴표없는 숫자데이터

    (3) 불린형 : true / false
        - 따옴표없이 위와 같이 쓰면 조건식결과로
        true/false를 사용함!

    (4) 기타형 :
        - 날짜형
            (예: '2023-08-16')
        - 함수형
            (예: function(){} - 익명함수)
        - 배열형/객체형 
            (예:['aa','bb'],{aa:'가가',bb:'나나'})
        - undefined : 값이 할당안됨(정의안됨)표시 데이터
        - null : 빈값을 의미하는 데이터
        - 다른변수 : 할당하는 변수의 값이 할당됨!
            (다른변수의 주소가 할당되는 경우도 있음)

    _____________________________________

    7. 변수에 사용할 수 있는 문자
    - 주로 영문 알파벳을 사용하며 숫자로 시작할 수 없다!
    예) 12my -> X , my12 -> OK
    - 미리 JS에서 사용하는 단어는 쓸 수 없다!
    예) function, var, if, for, let, const, switch,...
    -> 이런종류를 예약어라고 함!
    
    _____________________________________

    8. 일반적으로 프로그래밍 언어에서 데이터형을
    선언시에 정해준다! 그런데 JS는 데이터형을
    정하지 않고 할당시에 데이터형이 자동으로 정해진다!

    -> JS 에서도 데이터형을 정해는 방법으롤 TypeScript가
    사용되고 있음! - MS에서 개발하고 배포함!

    _______________________________________

    9. 변수의 적용범위
    1) 같은지역에서 오직 하나의 변수는 중복되지 않는다!
    - 같은지역이란 같은 함수구역으롤 생각하자!

    2) 변수의 값을 중간에 변경하면 기존값이 덮어써진다!
    - 기존 데이터가 다른 데이터로 대체되어 바뀜!

    ___________________________________________

    10. 변수를 문자데이터 사이에 출력하기

    1) 일반적인 방법 :
        따옴표의 종류를 보고 해당 따옴표 사이를
        끊고 플러스 연산자로 변수를 연결함
        예) var home = '아름다운';
        "나의집" -> "나의"+home+"집";
        -> 결과: "나의 아름다운집"

    2) ES6의 새로운 방법:
        [ 템플릿 리터럴! ]
        https://www.w3schools.com/js/js_string_templates.asp

        -> 변수를 섞어쓸 문자 데이터를 따옴표를 안씀!
        백틱(back-tics:`)으로 쌈
        (백틱 내부에는 엔터가 자유롭다!)

        -> 변수는 ${...}로 삽입한다!
        ${...} -> interpolation(보간법,내삽법)
        -> 중괄호 사이에는 수식도 가능함!

        예) var home = "아름다운";
        "나의집" -> `나의 ${home} 집`

    __________________________________________________

    3) 참고: 리터럴(literal)은 무슨 의미?
    - 단어의 뜻이 '있는 그대로의' 처럼 데이터로 출력 될
    문자 데이터가 만들어져서 변하지 않는 데이터를 결과적으로 
    만들어짐을 의미한다.
    -> 리터럴 -> 니 있는대로 털어놔!
    - 프로그래밍에서 언급되는게 상수와 리터럴을 알아야 함
    상수 : 변하지 않는 변수
    리터럴 : 상수에 할당되는 변하지 않는 값을 말함
[ JS의 연산자 (Operator) ]
    - 연산자는 어떤 결과를 얻기위한 중간처리역할을 함

    1. 산술연산자 (사칙연산)
    1) 더하기 : +
    2) 마이너스 : -
    3) 곱하기 : *
    4) 나누기 : /

    -> 더하기 연산에 대한 결과
    숫자+숫자=숫자
    문자+숫자=문자
    문자+문자=문자
    변수+변수=변수값에 대한 더하기 연산

    ->빼기, 곱하기, 나누기는
    모두 숫자만 가능한 연산이다!
 3. 비교연산자:
    - 두 가지 값을 비교하여 
    true / false 의 결과값을
    얻는 연산자

    1) > : 크다(초과)
    2) < : 작다(미만)
    3) >= : 크거나 같다(이상)
    4) <= : 작거나 같다(이하)
    5) == : 같다(동등비교)
        예) 1 == '1' -> true
    6) != : 같지않다(동등비교)
    7) === : 같다(동등비교-형까지비교)
        예) 1 === '1' -> false 왜? 형이달라!
    8) !== : 같지않다(동등비교-형까지비교)

    ※ 주의사항: 비교연산자의 결과로
        반드시 true / false 가 나온다!
4. 대입연산자 :
    - 기존값에 연산을 중첩시키는 연산자

    1) += : 기존값에 더함
        예) A += 5 와 같은 것은 A = A + 5
    2) -= : 기존값에 뺌
        예) A -= 5 와 같은 것은 A = A - 5
    3) *= : 기존값에 곱함
        예) A *= 5 와 같은 것은 A = A * 5
    4) /= : 기존값에 나눔
        예) A /= 5 와 같은 것은 A = A / 5
    5) %= : 기존값에 나머지 연산함
        예) A %= 5 와 같은 것은 A = A % 5

    ※ 주의사항 :
    += 대입연산자는 붙여서 사용할것!
    (+ = 는 안됨)
5. 증감연산자 : 기존값에 1씩 더하거나 뺌
    ++ : 1씩증가
    -- : 1씩감소
________________________________________

    ++ 이나 --를 변수 앞이나 뒤에 붙일 수 있다
    변수 자신의 수를 증감할 경우엔 동일함!
    다른변수에 할당 시 의미가 달라진다!

    (1) ++을 뒤에 쓸 경우
    앞변수 = 뒷변수++
    해석: 뒷변수를 먼저 앞변수에 할당한 후
        뒷변수를 1증가한다!

    (2) ++을 앞에 쓸 경우
    앞변수 = ++뒷변수
    해석: 뒷변수를 1증가 후 앞변수에 할당한다!

    (--도 마찬가지임!!!)
6. 논리연산자 : true / false가 나오는
    경우에 이를 조합하여 결과를 리턴하는 연산자

    (1) 논리합(OR) -> || (바를 2개쓴다)
        - 여러조건 중 하나만 true 이면 true
    (2) 논리곱(AND) -> && (엔퍼센드를 2개쓴다)
        - 여러조건 중 모두 true 이면 true
    (3) 논리부정(NOT) -> ! (느낌표)
        - true 이면 false, false 이면 true

7. 조건연산자(삼항연산자)
    - if문과 유사하게 조건에 맞으면 실행할 수 있는
    코드를 구분해 주는 연산자다!
    -> 개발자들이 코드를 줄여쓸때 if문 대신에
    많이 사용한다! 사랑한다!!!
    ________________________________

    형식:
    조건식 ? 실행문1 : 실행문2 ;

    -> 조건식이 true이면 실행문1을 실행하고
    조건식이 false이면 실행문2를 실행한다!

    예) 비?집:놀이동산;
    -> 비가오면 집에 있고 안오면 놀이동산간다!
    -> 항목이 3개여서 삼항연산자라고도 함!

변수는 바.렛.콘스트!!!

[ var ] : 함수영역변수(함수 안인지 밖인지가 중요함)

   변수호이스팅 됨
1. 함수영역 안에서는 지역변수
2. 함수영역 밖에서는 전역변수
3. 전역변수와 같은 이름의 변수를 선언없이 
    값을 할당하면 전역변수가 덮어쓰기가 됨
4. 함수영역에서 전역변수와 같은 이름의 지역변수를
    선언하여 사용하면 전역변수와 연결성이 끊어지고
    지역변수만을 지칭하게 된다
5. 같은 영역에서 같은 이름의 변수를 다시 선언하면
    재 선언하여 관리함(덮어쓰기)
_______________________________________________
    (지역변수 : Local Variable)
- 의미 : 함수영역 내에 선언한 변수
- 특징 : 다른 함수나 바깥(전역) 영역에서 지역변수를
참조할 수 없다!
                
    (전역변수 : Global Variable)
- 의미 : 함수영역 밖에서 선언한 변수
- 특징 : 어떤 함수에서도 전역변수를 참조할 수 있다.
        즉, 사용가능!
- 용도 : 공유하고자 하는 데이터를 저장할 때 많이 사용
_______________________________________________

[ let ] : 블록영역변수 (중괄호는 모두 블록임!)

    변수호이스팅 금지
1. 선언하면 전역과 지역을 별도로 관리하여 
    같은 이름의 변수도 별개의 변수로 인식
2. 선언 후 아래쪽에서 사용해야만 함
-> 변수의 호이스팅(hoist:끌어올리다.) 금지
3. 같은 영역에서 같은 이름의 변수를 중복선언 불가!

***********************************************

[ const ] : 상수(constant) -> 변하지 않는값
1. 선언과 동시에 할당해야함!
2. 한번 할당한 값은 변경불가!
3. 배열과 객체, 함수를 상수로 만드는 경우가 많다!
-> 변경불가는 각 배열형, 객체형, 함수형
-> 변경가능은 각 배열값, 객체값, 함수전달값
4. 기타의 특징은 let과 동일함!(블록단위변수)

[ onkeypress 이벤트 속성 ]
    -> 키보드를 치면 발생하는 이벤트 속성
    if조건문
    조건식 : event.keyCode === 13
    -> 키보드의 키코드가 13번이냐? 엔터키 눌렀냐?
    -> 엔터키의 키코드는 13번이다! carriage return
    -> true이면 jumsu() 라는 함수를 호출해라!
    -> event 브라우저 내장 객체 : 이벤트 관련 객체
    참고) 키코드 참조: 아스키코드
    https://www.w3schools.com/charsets/ref_html_ascii.asp
[ label요소 ]
    input요소의 설명라벨요소
    - for속성 : 클릭시 아이디 input요소로 포커스이동
    [ input 요소 : 입력요소 ]
    - type = "text" -> 글자입력창
    - placeholder  -> 안내문구출력
    - maxlength -> 최대입력 글자수 제한
[ select 요소 ]
    1. 보통 정해진 선택값을 나열하여 선택입력을 하는 입력요소
    2. form요소 내부에 주로 사용되고 데이터를 DB에 전송하는 목적
    으로 많이 이용 됨!
    3. id를 설정할 때 name속성을 같이 셋팅할 경우가 많은데 이는 
    post방식 데이터 전송 시 서버서이드에서 name으로 데이터를 읽어
    가기 때문에 일반적으로 사용!
    4. 필수 하위 요소 : option
        -> 속성으로 value를 쓰고 사용하면 JS등 프로그래밍에서
        이 값을 읽어감
        -> value속성을 셋팅하지 않으면 option의 데이터를 읽어감

html요소를 선택할 경우 실행순서가 중요함
    html본문 요소를 모두 로딩 후에 수집선택해야 함

    [ 로딩 후 수집방법 ]

1. script 코드를 body 태그 하단에 쓰기
2. 로딩구역을 만들어준다.
window.addEventListener('load',함수);
-> 대상 : 전체 브라우저 window객체
-> 이벤트 : 
    (1) load : 전체요소가 모두 로딩 후 발생(이미지, 비디오 등)
    (2) DOMContentLoaded : HTML요소만 다 그려지면 발생!(패키지요소 빼고)
    -> 위의 두가지는 실행 시점이 다르다
    -> 실행속도는 2번이 더 빠름
3. 외부JS 호출 시 defer 키워드 사용!
    script src='외부.JS경로' defer/
    -> html 요소 로딩 후 외부 JS를 실행

    [ 이벤트 함수 연결 내장함수 ]

대상요소.addEventListener(이벤트명, 함수);
    -> 이벤트 발생 시 함수와 연결하는 기능을 가진 JS 내장함수

    [ 요소 속성 값 넣기 ]
                    
    1. 선택요소.속성명 = 값;            :할당식
    2. 선택요소.setAttribute('속성명',값) :JS내장객체
    참고) 선택요소.getAttribute('속성명')  : 속성 값 읽기

[ JS 배열의 정렬 ]

    용어의 정의: 정렬이란?
        -> 배열의 값을 기준으로 순서를 다시 정하는것!
        -> 배열의 정렬은 sort() 메서드 사용!
    sort() 메서드를 사용하여 배열의값을 오른차순,내림차순으로 정렬할 수 있음!

    [ sort() 메서드의 특징 ]

    1. 기본정렬 : 
        오름차순(1,2,3,.../a,b,c,...) -> sort()
        내림차순 메서드 -> reverse()
    2. 원리 : 
        배열 값을 문자열로 캐스팅(형 변환)한 후 변환 된 문자열을 비교하여 순서를 결정함
        (참고: undefined 값일 경우 배열 맨뒤에 배치함)
        ***주의: 숫자를 비교해도 문자열로 비교함
        "25"와 "100"중 큰 숫자는 100이지만 문자형으로 비교하여 
        앞자리인 1과 2를 먼저 비교하여 "25"를 더 크게 정렬함

    [ sort() 메서드 비교함수 ]

    -> sort() 메서드 내부에 2개의 전달값을 가지는 함수를 쓰면
    sort메서드 자체에서 값을 비교하여 배열값의 순서를 바꾼다!
    -> 숫자일 경우 빼기 연산을 함
    ((오름차순))
    배열변수.sort() -> 기본정렬
    숫자데이터배열.sort(function(a,b){return a-b;})
    숫자데이터배열.sort((a,b)=>a-b)
    ((내림차순))
    배열변수.reverse() -> 기본정렬
    숫자데이터배열.sort(function(a,b){return b-a;})
    숫자데이터배열.sort((a,b)=>b-a)
    -> a는 앞 데이터, b는 뒷 데이터


    ->>> 숫자형, 문자형에 무관하게 처리하기
    [ sort() 메서드만 사용하여 정렬잡기 ]

    (비교함수사용)
    배열변수.sort(function(x,y){
        if(x>y) return 1;
        if(x<y) return -1;
        return 0;
    })
    
    -> 단순화하기(삼항연산자사용!)
    배열변수.sort(function(x,y){
        return x == y ? 0 : x > y ? 1 : -1;
    })
    -> 더 단순화 하기
    배열변수.sort((x,y)=>x==y?0:x>y?1:-1);

    -> 리턴값의 의미(오름차순)
    1) if(x>y) return 1; -> x가 y뒤에 옴 (리턴값 양수)
    2) if(x<y) return -1; -> x가 y앞에 옴 (리턴값 음수)
    3) return 0; -> x,y 정렬을 유지 (리턴값 0)

    -> 내림차순은 양수/음수만 반대로 써주면 된다!

    [ 정렬시 데이터 유의사항 ]
    1. 문자형일 경우 대소문자가 섞여있으면 대문자나 소문자중
    하나로 통일하여 비교해야함(toUpperCase()/toLowerCase())
    예)
    배열변수.sort((x,y)=>{
        let a = x.toUpperCase(),
            b = y.toUpperCase();
        
        return a == b ? 0 : a > b ? 1 : -1;
    })

    2. 날짜정렬도 숫자와 동일함(날짜데이터 자체가 숫자형으로 되어있음)

    3. 특정언어의 특수문자일 경우 localeCompare() 메서드로 
    문자열 비교를 한다!
    예) 특수문자 x변수를 y변수와 변환후 비교 
    x.localeCompare(y)

*************************************************************

    [ 배열의 검색 : find() / filter() / indexOf() ]

    1. find() 메서드
    (1) 검색후 첫번째 일치값 하나만을 리턴
    (2) 결과가 없으면 undefined 리턴(if문에서 false처리!)
    (3) 콜백함수구성 : function(val,idx,obj){}
        1) val : 처리중 배열의 값
        2) idx : 처리중 배열의 순번
        3) obj : 처리중 배열전체
    (4) 리턴데이터 : 배열의 값 하나(값의 데이터형)
    (5) 활용케이스 : 아이디검사 결과 리턴
    (6) 코드예 :
        변수 = 배열.find(v=>{
            if(v[속성명].indexOf(검색어)!==-1) return true;
        })
        -> 배열을 자동순회하여 if문에 해당되는 데이터가 있으면
        return true 하여 할당된 변수에 저장하고 문장이 바로 끝난다!


    2. filter() 메서드
    (1) 검색후 모든 일치값을 리턴
    (2) 결과가 없으면 빈배열 리턴([]->배열.length 값이 0)
    (3) 콜백함수구성 : function(val,idx,obj){}
        1) val : 처리중 배열의 값
        2) idx : 처리중 배열의 순번
        3) obj : 처리중 배열전체
    (4) 리턴데이터 : 배열형데이터(하나여도 배열값으로 넘어옴!)
    (5) 활용케이스 : 검색리스트 결과 리턴
    (6) 코드예 :
        변수 = 배열.filter(v=>{
            if(v[속성명].indexOf(검색어)!==-1) return true;
        })
        -> 배열을 자동순회하여 if문에 해당되는 데이터가 있으면
        return true 하여 다른값이 계속 나올때까지 배열로 값을
        할당변수에 저장한다!(배열을 전체순회함!)

    3. LIKE 검색방법 : 값의 일부만 넣어도 검색되는 방법
    -> indexOf(값) 을 사용함!
    결과값으로 문자열의 위치순번을 리턴하는데
    만약 없으면 -1을 리턴하므로 이것을 이용하여 
    조건문에 -1이 아닌경우가 검색결과가 있는 경우가 됨!
    예) 
    if(문자열.indexOf(검색문자열)!==-1){결과리턴}

    [ 객체를 배열로 변환하여 리스트 만들기 : 정렬시 필수! ]

    1. 대상: 배열이 아닌 객체형식으로 되어 있는 데이터를
            리스트로 만들고 이를 배열정렬 메서드를 사용코자할때
    
    2. 변경방법:
        (1) 객체의 속성(키)만 배열로 만들어준다!
        Object 객체는 객체를 위한 인터페이스 제공 객체임!
        -> Object.keys(객체)
        : 하는일 - 객체의 속성을 모아 배열로 만들어준다!
        -> 키배열을 만드는 이유는?
        ->>> 키배열 === 값배열 왜????
        -> 객체는 키를 통해 값을 부를 수 있기 때문이다!

        (2) 변경확인 
            변경전 : {속성1:값1,속성2:값2,...}
            변경후 : [속성1,속성2,...]

        (3) 속성을 값으로 하는 배열값으로 정렬을 변경할 수 있다
        -> Object.keys(객체).sort()

        (4) 객체값으로 구성되는 배열일 경우 아래와 같이 변환한다
        -> 객체를 변환후 map으로 값을 다시 담아준다!
        객체변수 = 객체
        새변수 = Object.keys(객체변수).map(v=>객체변수[v])

    3. 새로구성한 객체 변환 배열로 기존 배열 메서드를 사용하여
        정렬, 검색 후 정렬 등을 수행한다!!

import langCode from './data_lang.json' assert{type:'json'};
// import langCode from './data_lang.json' 어서써{타입:JSON};
// 원래 제이슨파일과 같은 데이터 파일을 불러올 때는 데이터 파일을
// 다 불러온 후에 그 데이터를 이용하는 코드가 실행될 수 있도록 하는
//  비동기 코딩 방식인 Promise를 사용하는 것이 원칙이다.

[ Math 객체 ]
    - 수학객체로써 다른 객체와 달리
    new키워드 없이 바로 사용할 수 있게 설계됨
    - 이런객체를 정적객체(Static Object)라고함
    -> 정적객체들!
        Array(), Object(), Math()
    ______________________________

    [ 주요 Math 객체의 메서드들 ]
    Math.min(값들) - 최소값
    Math.max(값들) - 최대값
    Math.round(실수값) - 반올림
    Math.floor(실수값) - 내림
    Math.ceil(실수값) - 올림
    Math.abs(양수나 음수값) - 절대값
    ______________________________

    Math.random() - 난수발생
    -> 0~1  사이의 소수점값 17자리수

[ 내가 원하는 난수 만들기 ]

    1. 먼저 난수를 발생시킨다!
    Math.random()

    2. 1부터 원하는 최대수일 경우 최대수를 곱한다
    Math.random() * 최대수

    3. 원하는 범위의 난수를 올림처림함
    Math.ceil(Math.random() * 최대수)

    ________________________________

    [ 중간 범위의 난수 만들기 ]

    1. 1부터 최대수 랜던수를 먼저구한다
    Math.random() * 최대수

    2. 원하는 범위의 시작수 만큼 더함
    Math.ceil(Math.random() * 최대수) + 시작수만큼

    (만약 0부터 시작수로 하면 내림을 적용!
    -> Math.floor())
    ___________________________________

    예) 4~9 사이의 난수 구하기 : 1~6먼저구함
    -> 최대수는 6, 시작수 만큼 더할 수는 3
    Math.ceil(Math.random() * 최대수) + 시작수만큼
    Math.ceil(Math.random() * 6) + 3
    ________________________________

    [ 중간범위 수 계산 ]
    작은수 ~ 큰수
    1. 최대수 = 큰수 - 작은수 + 1
    2. 시작수차이 = 작은수 - 1;

[ JS 로컬스토리지 : localStorage ]
    - window하위객체 window.localStorage
    -> window는 주로 생략함!
    -> 개발자 모드 'Application'탭에서 확인 가능

    1. 정의 : 
        브라우저별 로컬 어플리케이션 영역에 저장되는 스트링데이터 저장소(JS API)
    2. 유지 : 같은 PC, 같은 브라우저(재설치없이사용) 일 경우 계속유지됨
        (단, 같은파일일 지라도 여는 경로에 따라 같은 변수도 따로 관리된다! 
            - 기준이 도메인경로/주소)
    3. 특징 : 모드 데이터는 키,값 쌍으로 구성
             데이터값은 반드시 문자형으로 사용됨
    4. 응용 : 데이터로 배열/객체를 사용할 경우 문자형 변환하여 넣고 다시 객체형으로 파싱하여 사용한다!
        (1) 입력시 : JSON.stringify(배열/객체)
        (2) 사용시 : JSON.parse(문자형배열/객체)
        -> JS의 제이슨 데이터 파싱 메서드 : 
            JSON.parse()
        -> JS의 제이슨 형식 데이터를 문자열로 변환하는 메서드:   
            JSON.stringify()
    5. 사용메서드 : 
        (1) 값설정 : setItem(키명,값)
        (2) 값읽기 : getItem(키명)
        (3) 전체지우기 : clear()
        (4) 키번호읽기 : key(순번) -> 0부터 (키이름리턴)
        (5) 개별항목삭제 : removeItem(키명)
        (6) 개수 : length

    [ JS 세션 스토리지 : sessionStorage ]
    -> 로컬스토리지와 세션스토리지의 메서드는 동일함!
    -> 로컬스토리지와 차이점은?
    -> 브라우저가 닫히면 데이터가 사라진다!
    (로컬세션의 개념은 서버세션과 달리 하나의 브라우저탭을
    단위로 한다!)
    -> 서버세션은 접속된 로그인정보세션을 서버에서 관리하는 단위임

    [ JS 로컬 스토리지 / 세션 스토리지 장단점 ]
    (1) 장점: 간단한 프론트엔드 데이터를 DB없이 테스트해보는데 탁월함
    (2) 단점: 데이터의 지속 보장이 없다!
        (그나마 로컬 스토리지는 브라우저 경로가 같고 PC가 같고
        브라우저종류가 같다면 지우기 전까지는 데이터를 유지한다!)


    -> w3 schools 참고
    https://www.w3schools.com/js/js_api_web_storage.asp

[ 배열(Array) 변수란? ]

    - 여러개의 데이터를 묶음으로 변수하나에 저장함
    - 장점: 데이터를 취급하고 다루는데 편의성 제공
    - 각 데이터를 하나의 이름으로 구분하여 호출 할
    수 있는 메모리공간이다!
    (예: 계란한판, 아파트 등)

        [ 배열의 선언의 2가지 방식 ]

    1. new 키워드 선언방식
    - new Array()
    객체를 실제로 메모리안에 생성하는 방법을 제공
    이를 인스턴스(instance)라고 함!
    2. 리터럴 선언방식 (배열리터럴)
    - 변수 = []
    - 객체란 속성과 메서드를 가지고 있는 프로그램 단위체
    - 객체는 독립된 특성을 가지고 있어야함!

    예컨데 자동차, 볼펜, 물통, 가방 등
    독립된 별도의 기능이 있어야하고 명사적특징과
    동사적 특징이 모두 있어야 객체다! 
배열값 전체찍기 
        // 1. valueOf()
2. join(구분자) : 변수전체찍기에서 사이에 구분자 변경
        // -> 구분자를 넣고 문자값 생성
        console.log('arr3배열 구분자 문자찍기: ',arr3.join('^'));
배열값 사이에 음표(🎵)을 넣어서 출력하기!
        // 출력대상 : target[2]

[ 객체(Object) 란? ]

    - 일반적으로 JS에서 객체란 속성과 메서드를
    가지는 프로그램 단위체
    - 속성은 명사적 특징, 메서드는 동사적 특징
    객체예)
    https://www.w3schools.com/js/js_objects.asp
    - 자동차의 명사적특징: 핸들, 백미러, 트렁크, 바퀴 등
    - 자동차의 동사적특징: 운전하다, 멈추다, 주차하다 등

    (참고: 브라우저에 이미 만들어져 있는 객체들)
    -> 내장객체라고함!
    -> 브라우저 내장객체-> 봄(BOM:Browser Object Model)
    -> https://www.w3schools.com/js/js_window.asp

    window : 윈도우(브라우저화면) 표시 관련객체
    document : 문서구조에 관련된 객체
    Array : 배열객체
    Object : 객체를 만들기 위한 객체
    Date : 날짜객체
    Math : 수학객체
    ___________________________________

    ->>> 내장객체 중 객체를 만들기위한 객체인 Object를
    사용하여 객체를 만들어보자!

    [ 객체의 선언의 2가지 방식 ]
    1. new 키워드 선언방식
    - new Object()

    2. 리터럴 선언방식(객체리터럴)
    - 변수 = {}

    [ 객체의 할당 ]
    - 중괄호{}를 사용하여 할당코딩을 함
    - {속성명:값,속성명:값,...}
    - 여러값을 셋팅할때 콤마로 구분한다
    - 배열과 비교해서 이해하기 쉽고 호출하기 쉽다!
    - 객체 스타일로 데이터 구조를 만들고
    이런 파일로 DB와 데이터 통신을 한다!
    이 파일의 이름은? 제이슨(JSON:확장자.json)

    [ 객체의 호출 ]
    - 객체명[속성명]
    또는
    - 객체명.속성명
[ new 키워드 없이 바로 객체 생성하기 ] 
    -> 객체 리터럴 (추천방식!)

    - 방법: 변수 선언 후 이퀄 뒤에 바로 중괄호 사용!
    예) let obj = {속성명:값,속성명:값,...};

    [ 객체의 속성 셋팅시 문자형 또는 변수형 사용하기 ]
    
    1. 문자형 속성 - 따옴표로 싸는 방법

    예) let obj = {"나는나":"호호호","너는너":"하하하"}
    -> 문자형 속성의 객체 호출시
    객체명[문자형속성명]
    예) obj["나는나"]

    2. 변수형 속성 - 따옴표로 안싸는 방법
    예) let obj = {name:"김수현",tall:"186cm"};
    -> 변수형 속성의 객체 호출시
    객체명.속성명
    예) obj.name

    또는

    객체명["속성명"]
    예) obj["name"]
    -> 반드시 변수형 속성명을 따옴표로 싸서
    문자형으로 표시해야함!
    obj[name] -> 에러남!

    -> 만약 문자형으로 설정된 경우에도
    변수형으로 사용될 수 있는 문자면 변수형호출가능!
    예) var obj = {"하하하":"나나나"}
        obj["하하하"] 또는 obj.하하하

[ 배열의 복사 - 깊은 복사, 얕은 복사 ]
// 변수에 데이터 얕은 복사(주소 복사)
// const copyData = arrData;
// 변수에 데이터 깊은 복사(값 복사)
const copyData = JSON.parse(JSON.stringify(arrData));


[ 함수란? ]
    - JS의 특정실행코드 담고 있는 메모리 공간
    - 특징: 함수는 호출시에만 실행된다!
            함수는 주로 이벤트와 연결되어 사용된다!
    - 형식:
        function 함수명(변수){
            ... 실행코드 ...
            return 값;
        }

    [ 함수의 주요사항 ]
    1. 함수의 소괄호에 사용되는 변수는 안쓸 수 도 있고
        1개이상 변수를 사용할 수 있다.
        - 여러개 사용할 경우 콤마로 구분한다.
        - 이런 변수를 파라미터변수(전달변수)라고 부른다.
        - 이 변수는 함수 내부에서만 사용하므로 지역변수라고함
            (다른 함수나 함수 바깥쪽 영역에서는 
                이 변수를 알 수 없음!)
        - 파라미터변수는 선언하지 않는다!(자동선언됨)
        - 파라미터변수의 개수만큼 함수 호출시 같은 개수의 값을
        보내야한다!!!

        ->>> 파라미터 변수 없이 전달값 받는 방법
        함수안에 arguments라는 변수받는 배열변수가 셋팅된다!
        보낸 순서대로 배열순번으로 찍을 수 있다!
        (단, 화살표함수에서는 사용불가!)
        예) 
        function Fn(){
            console.log(arguments[2])
            // 아래호출에 따라 콘솔에 "사람"이 찍힘!
        }
        호출코드:
        Fn("고양이","강아지","사람");

    2. 함수를 나오기 전에 return  키워드를 쓰고 그 뒤에 
        값을 담은 변수나 어떤값을 쓰면 함수를 호출한 곳으로
        돌아올때 이 값을 가지고 돌아간다!
        (리턴값을 사용안 할 수도 있는 옵션이다!)

    3. 함수의 호출:
        - 함수명(값)
        - 함수를 호출할때는 반드시 오른쪽에 소괄호가 있어야함!
            (소괄호 없이 사용하면 그것은 변수다!)
        - 소괄호의 값은 함수의 파라미터변수의 개수에 따라 달라짐

    4. 함수를 만들고 먼저할일!
        - 함수가 호출되는 여부를 확인한다!
        (확인방법: alert, console.log 등)
    
    5. 전역변수, 지역변수

        (1) 전역변수(Global Variable) 는 함수바깥쪽에 선언한
        변수다. 따라서 모든 다른 함수에서 이 변수를 참조할 수 있다.

        (2) 지역변수(Local Variable) 는 함수 내부에서 선언하거나
            파라미터변수를 말한다. 함수 외부나 다른 함수에서 이를
            참조할 수 없다. 지역변수는 다른 함수에서 선언된 같은
            이름의 변수명을 사용할 수 있다.
        
    6. 함수명은 대소문자를 철저히 구분한다!
        예) myHome(), MyHome(), myHOME() 모두 다른함수임!!


    [ 함수의 종류 ]

    1. 선언적 함수(이름있는함수)

    - 브라우저 인터프리터(우리가 사용하는 문자로된 코드를
    컴퓨터가 이해할 수 있는 방식의 기계어로 해석해주는
    프로그램)가 프로그램 실행 전에 선언적함수만 따로 모아서
    VO(Variable Object)에 적재함. 따라서 선언적함수는
    어디서 호출해도 응답한다!!!

    (형태)
    function 함수명(){}
    -> 선언적 함수는 다른 함수 내부에 만들지 말자!
    -> 스크립트 구역 바로 안에 만들면 전역적 함수가 됨
    : 전역적 함수란 어디에서든 호출되는 함수를 말함.


    2. 익명함수(이름없는함수: Anonymous Function)

    - 함수 자체에 이름이 없고 변수에 할당을 하거나
    다른 메서드나 함수 내부의 함수자리에 사용한다!

    - 함수의 호출은 할당한 변수에 소괄호를 붙여서 호출함

    - 함수의 호출위치는 변수에 할당 후 아래쪽에서 호출해야함!
    (이유: 선언적함수와 달리 미리 VO에 적재되지 않고
    코드를 만나면 그때 생성되기 때문이다!)

    - 익명함수를 쓰는 이유 장점 :

    (1) 함수코드가 미리 로딩되지 않기 때문에 메모리 부담이
    적고 소스 로딩속도가 빠르다!

    (2) 바로 실행하면 안되는 코드를 직접 저장할 수 있다!

        1) 요소의 이벤트 속성에 코드를 할당해서 바로 실행하지
        않고 이벤트발생시에 실행하도록 코딩할때 유용함!

        예)

        document.getElementById("my")
        .onclick = function(){실행코드};

        2) JS내장함수의 외부 선언적함수를 만들지 않고
        바로 코드를 저장할 수 있다!

        예)

        document.getElementById("my")
        .addEventListener("click",function(){실행코드});

        3) 함수에서 코드를 리턴할때 익명함수를 사용함!

        예)

        function 함수명(){
            return function(){실행코드};
        }

        4) 제이쿼리에서 코드 작성 부분에 익명함수를 사용함!
        
        예)

        $(function(){실행코드});

    
    - 익명함수를 쓸때의 단점:
    함수를 생성 후 호출해야 하므로 코딩순서에 신경써야함!

    -> 익명함수의 활용도 높아서 JS 업데이트 버전에서
    줄여서 쓸 수 있도록 화살표함수(Arrow Function)를
    제공한다!

        function(){} 
        아래와 같이 줄여씀!
        ()=>{}

[ 타이밍 함수 (Timing Function) ]
    -> 일정시간 후 자동호출 기능의 JS내장함수

    1. 인터발함수 : setInterval(함수,시간)
    -> 설정된 시간 간격으로 함수를 계속 호출함!
    -> 1)함수 - 외부함수 / 익명함수 모두 가능
    -> 2)시간 - 1/1000초 (단위없이사용:1000->1초) ms단위
    예) setInterval(function(){코드},3000)
        -> 3초간격으로 코드실행!

    2. 타임아웃함수 : setTimeout(함수,시간)
    -> 설정된 시간 후 함수를 한번만 호출함!
    -> 1)함수 - 외부함수 / 익명함수 모두 가능
    -> 2)시간 - 1/1000초 (단위없이사용:1000->1초) ms단위
    예) setTimeout(function(){코드},800)
        -> 0.8초후 코드 한번만 실행!

    ->>> 함수가 외부에 있을 경우 그 함수명만 써서
    함수를 등록하거나 외부함수가 전달값이 있을 경우
    익명함수 구역 안에서 코드를 작성한다!

    예) setInterval(hahaha,2000);
        function hahaha(){코드}
        _________________________

        setInterval(function(){hahaha("넌누구냐?");},2000);
        function hahaha(txt){코드}

[JS 일반적인 실행순서]
    1. 위에서 아래로
    2. 이퀄 오른쪽에서 왼쪽으로
    3. 소괄호 안에서 바깥으로
    4. 함수바깥부터실행 호출시 함수실행

[ ES6에서 등장함 JS 함수 축약법! ]

    1. function 키워드, return 키워드, 중괄호 모두생략!
    2. 익명함수에 해당!
    3. 기본형: 
        function(){}
    4. 축약형:
        ()=>{}
    5. 확장형:
        ()=>{코드}
            매개변수가 없을때
        x=>{코드}
            매개변수(여기선x)가 하나일 경우 소괄호생략
        (x,y)=>{코드}
            매개변수가 여러개일 경우 소괄호 필수!
        _______________________________________

        (x)=>{return x*x;}
            일반적인 축약형 리턴
        x=>x*x;
            하나의 연결된 값으로 리턴할때
            return 키워드,중괄호 모두생략
        ________________________________

        ()=>{return {a:1};}
            객체리턴시 일반축약형
        ()=>({a:1};)
            객체리턴시 return 키워드 생략가능
            단, 소괄호로 싸준다!
        _________________________________

        아래와 같이 실행문이 있으면 중괄호필수!
        ()=>{
            const x = 10;
            return x*x;
        }

화살표함수를 사용할때 this 키워드의 의미는 다르다!!!

    화살표함수에서 this는 window객체를 의미!
    (자신을 생성한 객체를 가리킨다! 즉, 여기서는 window로딩구역안에 생성되어서
    window객체를 가리키고 만약 이것이 어떤 Object안에 메서드라면 그 Object를 가리킴!)

    this 키워드 대신 event.currentTarget 을 사용하여 현재요소 자신을 의미하도록 코딩해야함!

    ________________________________________________

    [ ES6 버전 JS란? ] - EcmaScript를 줄여서 ES라고함

    -> EcmaScript는 JS의 다른이름!
    -> JS가 계속 업데이트가 되었지만 2015년에
    업데이트는 많은 변화가 있었음!
    이때 객체지향언어적인 변격이 이루어짐!
    (객체지향언어란 각 모듈별 관리가 가능한 프로그래밍언어!)
    -> 업데이트 내용:
    let, const 추가, Arrow function, Class 구현추가 등
    -> 이런 새로운 내용으로 코딩하는 JS를 모던JS라고 부르기도함!

    -> 내용확인!
    https://www.w3schools.com/js/js_es6.asp

[ this 키워드란 무엇인가? ]

    JavaScript에서 this키워드는 객체 를 나타낸다
    어떤this 객체가 호출 되는지에 따라 달라진다
    this키워드는 사용 방법에 따라 다른 객체를 참조한다
    ___________________________________________

    1. 객체 메서드에서 객체자신을 의미
        - 단, 화살표함수는 전역객체(window)를 의미
    2. 단독으로 전역객체(window)를 의미
    3. 함수에서 전역객체(window)를 의미
    4. 함수에서 엄격모드(use strict)일 경우 undefined
    5. 이벤트에서 이벤트를 수신한 요소자신을 의미
    6. 이벤트에서 화살표함수는 상위 이벤트요소를 의미
        (단, 상위 이벤트요소의 함수는 화살표함수가 아님!)
    엄격모드 : 선언없이 쓰는 변수를 막는 등 엄격한
    JS문법을 적용하도록 제한한다!(프로젝트에서 선호됨!)
    "use strict";
    (참고) https://www.w3schools.com/js/js_strict.asp

[ 생성자 함수란? ]
    - 쉽게 말해서 함수를 이용해서 객체를 생성하는 템플릿이다!

    - 객체도 객체 리터럴을 통해 쉽게 만들 수 있지만 
    데이터의 분량만큼 객체를 형식에 맞게 생성해야하는 불편함이 있다. 이것을 해결하기 위해 나온 것이 생성자 함수다!
    (*객체 리터럴이란? 변수에 중괄호를 할당하여 바로 객체를 생성하는 방법 -> 변수={} )

    - 생성자함수는 일반함수와 만드는 방법은 동일하다!

    - 차이점은 아래 6가지다!

    1. 함수명은 일반함수와 구분하기위해 첫글자를 대문자로 씀

    2. 템플릿 속성명에 해당하는 변수를 모두 this키워드로
    등록하여 인스턴스를 생성한 경우 접근할 수 있도록한다!
    (this키워드로 등록하지 않으면 new키워드 생성후
    변수에 접근할 수 없다!)

    3. 데이터 셋팅 및 호출을 위해 new키워드로 생성자함수를
    변수에 할당한다!(인스턴스를 생성함!)

    4. 값의 셋팅은 일반함수에 호출시 전달값을 주는 것과 같다

    5. 셋팅된 값은 함수에서 this키워드로 등록된 변수를
    아래의 형태로 호출할 수 있다!
    -> 생성자함수.변수명 

    6. 생성자함수엔 보통 return문이 없다!
    이유는 기본적으로 this키워드에 저장된 정보가
    자동으로 return되기 때문이다.
    따라서 return문을 명시적으로 써줄 필요가 없다!
    (만약 return을 쓰게되면 객체일 경우 그것만 반환되고
    그냥 return키워드만 쓰게 되면 자동으로 this가 반환됨!)

[ JS 클래스란? ]

    1. ES6버전에서 JS 클래스가 도입됨! ECMAScript
    2. JS 클래스는 JS 객체용 템플릿이다!
    3. JS 클래스는 객체가 아니다! 함수의 일종이다!
    4. JS 객체를 위한 템플릿이다!
    5. 클래스는 엄격모드("use strict")에서 사용된다!
    (만약 엄격모드를 설정하지 않으면 class를 사용하는
    JS는 자동으로 엄격모드로 적용된다!)
    ____________________________________

    (참고: 엄격모드란 JS를 좀더 엄격하게 문법적용을
    하도록 지정하는 방법이다!)
    -> https://www.w3schools.com/js/js_strict.asp
    예) 선언없이 사용하는 변수에 에러처리
    ______________________________________

    ((클래스 구문))

    class ClassName {
        constructor(){...}
    }
    -> 기본적으로 클래스안에
    constructor() 메서드를 필수로 생성함! - 기본메서드
    -> 객체의 속성을 셋팅하는 역할을 한다
    -> 일명 '속성세팅 메서드'라고도 함
    -> 공식명칭 '생성자메서드'
    ****************************************

    ((클래스 메서드))

    class ClassName {
        constructor(){...}
        method_1(){...}
        method_1(){...}
        method_1(){...}
    }
    constructor() 메서드 아래에 하나씩 생성한다.
    ___________________________________________

    ((클래스로 생성 할 객체 모델))

    객체모델:
    1. 속성6가지-> constructor()메서드 안에 구현
        포스터,제목,개요,감독,출연,문구
    2. 함수1가지-> 실행할 메서드

[ JS 클래스 상속 ]
    1. 클래스 상속은 extends 키워드 사용
    2. 클래스 상속으로 생성 된 자식 클래스는 
    부모 클래스의 모든 속성과 메서드를 상속한다!
    3. 상속은 코드를 재사용하는 대표적인 방법이다!

    [ super() 메서드 ]
    1. 부모 클래스를 참조한다.
    2. 부모 생성자 메서드를 호출한다.
    3. 부모 클래스의 속성과 메서드에 접근 가능하다.
    4. 부모 클래스의 메서드를 선별적으로 가져올 수 있다.
    -> super.부모메서드()
    -> 부모 메서드 호출시엔 super키워드만 사용함!

    ___________________________________________________

    [ 겟터와 셋터 ]
    1. 클래스의 특정속성에 대하여 겟터와 셋터를 설정할 수 있다.
    2. 겟터(Getter) : 값을 리턴함
        get 겟터명(){
            return this.속성변수
        }
    3. 셋터(Setter) : 값을 셋팅함
        set 셋터명(전달변수){
            this.속성변수 = 전달변수
        }
    4. 값의 호출 : 겟터명을 변수호출함
    5. 값의 셋팅 : 셋터변수에 할당함

    (주의사항)
    -> 겟터명과 셋터명은 동일함
    -> 사용시 변수처럼 사용함(소괄호없음)
    -> 호출시엔 본래 클래스 맴버 속성을 사용할 수 있음
    -> 값셋팅은 셋터를 사용함(원본에 할당도 가능함)
    -> 겟터,셋터 사용목적은 값에 대한 유효성 검사임!
    _______________________________________________

    [ 상속 모델 시나리오 ]
    1. 영화진흥위원회에서 전체 영화정보에 대한 기준을 
    마련하여 클래스로 공개를 했다.
    2. 각 영화상영관 사이트에서 이 기준을 따르기로 하고
    클래스를 상속한다!
    3. 각 상영관은 자신에 맞는 별도의 속성과 메서드를
    구현하여 사용한다!

    [ 문자 데이터 가공 ]

1. 문자치환함수: replace(바뀔값,바꿀값)
    - 특정문자를 다른문자로 변경해주는 JS내장함수
    -> 바뀔값이 여러개이면 정규표현식을 쓴다!
   
2. 문자추출함수

        1) substr(시작순서,개수)
        -> 대상문자열에서 시작순서를 0부터셈,
            개수는 시작순서부터 몇개의 문자인지 씀

        2) substring(시작순서,끝순서) (시작순서,시작순서+개수);
        -> 대상문자열에서 시작순서를 0부터셈
            끝순서는 0부터 세서 보이고자하는 문자뒷문자번호를 씀

    3) 공통사항 : substr(시작순서) / substring(시작순서)
    -> 시작순서만 쓰면 시작순번부터 끝까지 문자열을 가져온다!
3. 문자 자르기 함수 : split(자를기준문자열)
    -> 문자열을 기준문자로 split하여 자르면 배열이 된다!
4. String(숫자데이터)
    -> 숫자형 데이터를 문자형으로 변환
      
 [ 정규 표현식(正規表現式, 영어: regular expression, ]
    간단히 regexp 또는 regex, rational expression)
    또는 정규식(正規式)은 특정한 규칙을 가진 문자열의 집합을
    표현하는 데 사용하는 형식 언어이다.

    예) 이메일형식, 전화번호형식, 아이디구성형식, 비밀번호형식

    [ 간단한 정규식 표현기호 ]

    1. 정규식 내용은 따옴표를 쓰지 않고 슬래쉬를 사용함

    2. 모든 패턴문자열을 찾을때 g라는 플래그문자를 사용함

        g는 global 에서 온말 즉, "전역"이라는 의미
        - i 플래그문자는 대소문자 구분안함 표시자

    예) /,/g -> 모든 콤마문자를 찾아라
        /s/gi -> 모든 s문자를 대소문자 구분없이 찾아라

    -> 참고 사이트:
    https://www.w3schools.com/jsref/jsref_obj_regexp.asp

[ 숫자 데이터 가공 ]

1. 숫자변환 : Number(문자형숫자) -> 숫자형변환
2. 숫자여부판별 : isNaN(값)
    - 값이 숫자가 아닐경우 true를 리턴함
    - is Not a Number ? (숫자가 아니니?)
    - 답변: true(응, 숫자가 아니야!) / false(아니, 숫자야!)
3. 숫자추출(숫자형변환)

        1) parseInt(숫자+문자)
        -> 정수(Integer)형인 숫자만 추출하여 정수형 숫자로 변환함

        2) parseFloat(숫자+문자)
        -> 실수(Float)형인 숫자만 추출하여 실수형 숫자로 변환함

        - 원래는 parseInt, parseFloat 은 형변환함수임!
        - 웹에서 주로 숫자뒤에 단위가 붙은 경우가 많은데
        계산할때 단위가 있으면 숫자 계산이 안되기 때문에
        형변환하면 단위를 자동으로 없애고 숫자만 계산해준다!

        - 유의사항: 문자+숫자 형식은 변환되지 않는다!     
4. 문자로된 숫자계산식을 실제로 계산하기
    - 문자식을 이발해주면 실제로 계산한다!
    - eval(문자로된 계산식)

★★★★★★★[ DOM event객체 ]★★★★★★★

-> 모두 읽기(Read) 속성 또는 호출실행 메서드임

1. DOM 표준을 준수하는 브라우저에서 이벤트 핸들러에 
    전달되는 매개변수는 event객체 오직 하나다!

2. DOM레벨(부모,자식관계)과 상관없이 event객체가 전달되며 
    event객체에는 생성에 관여한 이벤트와 관련된 프로퍼티 및 
    메서드가 포함된다


★★★★★★★[ event 객체 : 속성과 메서드 ]★★★★★★★

1. 불린값 속성  // bool : true || false
(1) bubbles (bool) : 
    이벤트가 버블링되는지 나타냄
(2) cancelable (bool) : 
    이벤트의 기본 동작 취소가능 여부
(3) defaultPrevented (bool) : 
    true면 preventDefault()호출상태

2. 숫자값 속성
(1) detail (integer) : 
    이벤트와 관련된 추가정보
(2) eventPhase (integer) : 
    이벤트 핸들러가 호출된 단계(1:캡처링,2:타깃,3:버블링)
(3) isTrusted (bool) : 
    브라우저에서 생성한 이벤트라면 true -> 일반적으로 이것!
    개발자가 만든 자바스크립트 이벤트라면 false

3. 요소 속성
★(1) currentTarget (element) : 
    현재 이벤트를 처리중인 element
★(2) target (element) : 이벤트 타깃

4. 이벤트 메서드
★(1) preventDefault() (Function) 
    이벤트의 기본행동 취소, (cancelable가 true일때)
★(2) stopImmediatePropagation() (Function) : 
    이벤트캡처링,이벤트버블링 모두 취소. 
    다른 이벤트 핸들러 호출을 막음. (같은 이벤트로 여러기능설정시)
★(3) stopPropagation() (Function) 
    이벤트캡처링,이벤트버블링 모두 취소 (bubbles가 true일때)

5. 기타 속성
(1) type (string) : 
    발생한 이벤트 타입
(2) view (AbstractView) : 
    이벤트와 연결된 추상화된 뷰다. 
    이벤트가 발생한 window객체와 일치

★★★★★★★[ 이벤트 흐름 ]★★★★★★★

1. 캡쳐단계 : 최상위 부모요소로부터 말단요소까지 내려감

2. target 단계 : 현재 이벤트가 발생하는 요소 (event.target으로 구함)

3. bubling 단계 : target 에서 부터 최상위 부모까지 이벤트가
    전달되는 현상(주의사항: 같은 종류의 이벤트가 전달된다!)
    -> 느낌 참고: 토르망치!
    https://mblogthumb-phinf.pstatic.net/20150915_245/qkdtoa9831_1442293878842KAb7K_GIF/glqkazhkd.gif?type=w2

4. 이벤트 버블링 차단:
-> event 객체 메서드 사용하기:
- event.stopPropagation() 메서드 사용
- 코드 위치는 어디나 사용가능
- 만약 같은 이벤트가 다른 기능으로 여러개 설정된 경우
다른 설정 기능까지 막으려면?
stopImmediatePropagation() 메서드 사용!

->>> 주의: 이벤트 버블링은 매우 유용한 기능이다!
따라서 매우 명백한 상황이 아니라면 되도록 사용말자!
예컨데 사용자 행동 분석툴에서 클릭빈도수를 분석할때
사이트에 버블링차단된 영역은 죽은영역(클릭수0)으로
표시되므로 분석이 불가능하게 되는 상황이 생길 수 있음!

★★★★★★★[ 이벤트 설정 및 해제 ]★★★★★★★

1. 이벤트 설정
(1) addEventListener(이벤트명,함수)
    -> 같은요소에 같은 이벤트로 다중설정가능!
(2) 이벤트속성 = 함수
    -> 같은요소에 같은 이벤트로 단일설정만 가능!

2. 이벤트 해제
(1) removeEventListener(이벤트명,함수)
-> 주의: 함수를 외부함수로 만들어야 해제가 가능하다!
(2) 이벤트속성 = ""; -> 빈 문자열값을 할당하여 지움

[ 요소의 생성, 삭제, 이동하기 ]

    1. 맨뒤 생성 혹은 맨뒤 이동
    -> 선택요소.appendChild(요소)

    2. 특정위치에 요소 넣기 혹은 이동
    -> 선택요소.insertBefore(넣을놈,넣을놈전놈)

    3. 요소의 삭제
    -> 선택요소.remove()

    4. 새로운 요소 생성 (메모리상에 생성함)
    -> document.createElement(태그명)

    5. 요소에 새로운 속성넣기 (메모리상에 생성함)
    -> document.createAttribute(속성명)

    6. 생성된 속성에 값넣기
    -> 생성된속성.value = 값

    7. 요소의 새로운 속성 넣기
    -> 선택요소.setAttributeNode(새로운속성)

[ DOM 여행 ]
요소.isSameNode(비교요소)
특정요소가 비교요소와 같으면 true / 같지 않으면 false
nextElementSibling 선택요소의 다음요소
previousElementSibling 이전요소선택
parentElement 부모요소 선택

[ 제이슨(JSON) 이란? ]
    객체형식의 데이터 저장파일
    객체는 Object 즉, {속성:값} 형식 데이터포멧

    - 이전에는 xml이 많이 쓰였으나
    지금은 제이슨이 대세임!
    - 이유는? 읽고 쓰기가 편리함. 가독성 좋음
    - xml과 json의 공통점:
    모두 DB에 넣고 빼는 text기반 데이터형식!

    -> 참고
    https://www.w3schools.com/js/js_json_intro.asp

    ________________________________

    [ JS에서 JSON사용하기 ]

    1. 먼저 제이슨 파일을 불러온다
    (단, 제이슨 파일안에 전체객체를 변수에 담아야한다! 
    -> JS에서 제이슨 사용시 필요!)
    -> 실습에서 사용하는 제이슨파일은
    jsonData라는 변수에 담았다!

    2. 변수에 제이슨 파일을 파싱하여 할당한다!
    let 변수명 = JSON.parse(JSON.stringify(제이슨할당변수))

    * 파싱이란? 문자열 데이터를 분석하고 분해하여
    목적한 패턴에 맞게 문자열구조를 결정하는것!
    -> JS의 제이슨 데이터 파싱 메서드 : JSON.parse()
    -> JS의 제이슨 형식 데이터를 문자열로 변환하는 메서드
        : JSON.stringify()
    
    3. 원하는 대로 객체호출 형식으로 사용한다!
    예) 객체변수명[속성명]

[ 에러처리 기본구문 ]

    try{} 실행코드블록
    catch(err){} 오류처리를 위한 코드블록
    finally{} 무조건 실행 코드블록
    _______________________________

    -> 에러 처리를 위한 구문구성
    try{
        if문사용 -> throw 키워드로 에러처리!
    }
    catch(err){
        throw로 들어온 메시지로 에러처리!
    }

    -> throw 문:
    사용자지정 오류를 기술적으로 예외처리방법
    예외처리형태 : 문자형, 숫자형, 불린형, 객체

[ 리액트란? ]

    -> 프론트엔드 JS 라이브러리다!
    -> 사용자 UI의 구성요소를 빌드하기 위한 도구
    (빌드란? html구조와 언어에 데이터를 바인딩하여
    배포하는 작업을 이름)

    [ 작동원리 ]

    -> 가상돔(Virtual DOM)을 사용하여 최소의 html리소스를 
    사용하므로 빠르고 쉽게 UI 화면을 구성한다!
    -> 가상돔은 실제 DOM을 변경하기 전에 
    메모리상에서 구현하는 오브젝트 DOM이다.
    -> 변경사항을 단위별로 한 번에 업데이트하기 위한 수단

    _______________________________________________

    [ 리액트 구현의 2가지 스타일 ]
    
    # 스타일1 : 리액트는 JS 라이브러리이므로 필요한 부분에만 적용이 가능하다.
    ->라이브러리는 CDN방식으로 구현(별도의 설치가 필요 없다)

    # 스타일2 : 리액트는 SPA(Single Page Application)이므로 
    Node.js등을 사용하여 한 페이지로만 구현하는 웹을 만들 수 있다.
    ->Node.js, 리액트 SPA 개발환경 설정이 필요함!

[ 리액트 특징 ]
    html 태그와 JS문법을 따옴표없이 사용하는 JSX문법을 사용한다!
    JSX(Javascript XML) 문법을 쓰는 파일은 .js대신 .jsx확장자사용!
    -> return 키워드 사용은 따옴표없이 바로 소괄호롤 묶어사용
    (소괄호 생략 가능!)

    [[ 주의사항 ]]
    1. 함수를 만들경우 반드시 대문자로 시작해야 호출됨!(정해진규칙) :생성자함수(객체를 생성하기 위한 함수)
    2. 홀로태그를 사용할때는 마지막에 스스로 닫기를 꼭 해줌!(/>)
    3. 함수 내부의 리턴값으로 만든 요소는 반드시 최상위요소가 하나여여함!

[ 리액트 html대상요소에 삽입하기 ]
가상돔을 셋팅하는 리액트 객체를 호출한다! -> ReactDOM
    render() -> 요소를 변경하는 메서드

    [호출형태]
    ReactDOM.render(요소를 리턴하는 함수명으로 된 홀로태그,대상요소)
    __________________________________________

    예컨데 함수명이 MyFirstReact이므로 
    요소를 리턴하는 함수명으로 된 홀로태그는? <MyFirstReact />

    그리고 대상요소는 JS문법으로 요소를 선택함!
    document.querySelector("#root")

[ JSX란 무엇인가? ]
    - Javascript XML을 나타냄
    - 리액트에서 HTML을 쉽게 작성할 수 있다.
    - appendChild() 메서드 없이 DOM에 요소넣기가 가능함!

[ 출력방식 정리! ]
    1. 한꺼번에 쓰기
    ReactDOM.render(출력할요소,대상요소)

    2. 따로쓰기
        1) 생성변수 = ReactDOM.createRoot(대상요소)
        2) 생성변수.render(출력할요소)

    _____________________________________________

    [ JSX 를 사용하거나 사용하지 않는 경우 ]
    -> 개발자의 선택사항이다!
    -> JSX는 ES6 기반의 자바스크립트 언어의 확장이며
    런타임시 일반 자바스크립트로 변환된다!

    ______________________________________________

[ JSX 표현식 ]

    JSX를 사용하면 중괄호에 표현식을 작성할 수 있다
    {........ 표현식 ........}

    -> 표현식이란 React변수, 속성, JS문법 등의 내용임

[ JSX 태그요소 작성시 여러줄일 경우 ]

    1. 최상위를 하나 만들고 여러요소를 작성한다!
    2. 소괄호로 전체를 싸준다!(소괄호생략가능!)

    - 지원되는 스타일:
    1) <>태그들</>
    2) <Fragment>태그들</Fragment>
    3) <기존태그>태그들</기존태그>

    -> 1),2)번은 CDN방식에서는 지원안함!(설치형SPA지원!)
    -> 2)번 CDN에서 사용하려면 아래와 같이 사용한다!
        <React.Fragment></React.Fragment>
    -> 1),2)번을 사용하는 이유는 쓸때 없는 태그삽입을 막는데있다!
    -> 기존태그는 <div>,<section> 등 원래있는 html태그를 말함
        (단점, 원하는 않는 태그가 삽입됨!!!)

[ JSX는 홀로태그라도 끝에 닫기를 해줘야한다! ]

    예) <br> -> <br />
    <input type="text"> -> <input type="text" />

[ JSX에서 속성 클래스는 className 으로 표기한다! ]

    <태그 class="클래스명">
    class는 JS에서 키워드이므로 사용못함! 대신...
    <태그 className="클래스명">

[ JSX에서 조건문 사용하기 - if문 ]

    리액트는 if명령문을 지원하지만 JSX내부에서는 지원하지 않는다!!!
    
    JSX에서 조건문을 사용하려면? JSX 외부에서 if문을 사용하거나 아니면 내부에서 삼항연산자를 사용할 수 있다!

[ 리액트 컴포넌트 ]
    - 컴포넌트는 HTML요소를 반환하는 함수다!

    [ 특징 ]
    1. 컴포넌트는 독립적이고 재사용이 가능한 코드집합
    2. JS함수와 비슷하지만
        HTML코드 반환이 필수라는 점이 다름!
    3. 컴포넌트는 다음 2가지로 생성가능함
        1) 클래스형 컴포넌트
        2) 함수형 컴포넌트
        (-> 우리는 함수형 컴포넌트에 집중할 예정!)

    -> 클래스형 컴포넌트는 리액트 초중기에 주로 사용되었으나... React 16.8버전에서 Hooks와
    함께는 더 이상 사용되지 않는다! Hooks는 함수형 컴포넌트에서만 사용가능하다!
    ____________________________________________

    [ 첫번째 컴포넌트 만들기! ]
    - 리액트 컴포넌트 이름은 반드시 첫글자가 대문자로 만든다!
    (안지키면 적용안됨!!!)

    [ 클래스 컴포넌트 ]
    클래스 컴포넌트에서는 extends React.Component 상속문이 포함돼야함!

    -> 컴포넌트에서도 메서드가 필요함 render() 메서드는 HTML을 반환함
    (함수형 컴포넌트의 return 키워드를 사용할 수 있는 역할을 함!)

[ Props 사용하기 ]

    props는 properties 에서 나온말
    속성들... 즉, 변수에 값을 할당하여 전달하는 방법
    함수의 전달값과 같고 속성으로 컴포넌트에 보낸다!

    1. 리액트 구성요소에 전달되는 인수다!(전달변수,파라미터)
    2. HTML 속성을 통해서 구성요소에 전달된다
    3. props는 속성이다.
    4. JS 함수에 셋팅되는 전달변수와 HTML속성과 동일함
    5. 컴포넌트로 보내기 위해서는 HTML속성과 동일한 구문사용

[ 컴포넌트의 파일분리 ]

    리액트는 코드를 재사용하는 것이므로 컴포넌트를 별도의 파일로 분할 하는것 일반적이다!

    {분할방법}
    1. jsx의 새파일을 생성한다.
    2. 대문자로 시작하는 컴포넌트를 구현한다.
    3. 분할구현된 jsx파일을 import하여 호출한다.

    -> 일반적으로 js파일 상단에 import 키워드로 불러오면 되는데 지금 사용하는 CDN방식의 바벨모듈에서는
    주의 사항이 있으니 참고 바란다!(아래참고) 
    
    [ 바벨을 사용할때 모듈로 파일 호출시 주의사항! ]
  ____________________________________________

  설치형이 아닌 CDN방식의 바벨은 호출셋업의 시차로 바로 모듈을 호출하면 에러가 발생한다!
  따라서 모듈을 사용할 파일을 아래와 같은 형식으로 메인 html 상단에 호출해 줘야만 한다!!!

  -> 상단에 모듈화한 JS를 먼저 불러준다!

  <script src="모듈화한js" 
  data-plugins="transform-es2015-modules-umd" 
  type="text/babel"></script>

  -> 아래쪽에 모듈을 호출하는 JS를 불러준다!

  <script src="모듈을 호출하는 JS" 
  data-plugins="transform-es2015-modules-umd" 
  type="text/babel"></script>

  ->>> 위의 호출 속성 중 기본적으로 type="text/babel" 은 당연히 해야하고

  ->>> 여기에 더하여 하나의 속성을 추가한다!
  data-plugins="transform-es2015-modules-umd"

  이 속성과 값이 바벨에서 모듈을 사용하게 하는 es2015 즉 ES6버전에서의 모듈문법을 사용하게끔 해준다!

[ 리액트 이벤트 ]

    1. 일반 HTML DOM 이벤트와 마찬가지로 사용자이벤트 사용가능함
    2. 이벤트 종류: click, change, mouseover 등 일반이벤트
    3. 이벤트 표기법: 캐믈케이스 - 첫글자소문자 단어마다 대문자
    예) onclick -> onClick
    4. 이벤트 핸들러 : 중괄호 안에 작성(중괄호는 JSX표현식영역)
    예) onclick="getIt()" => onClick={getIt}

[ 리액트 훅크 : React Hook ]
    
    일반적으로 리액트에 사용되는 변수는 처음에 컴포넌트에 전달되어 초기 셋팅에 활용된다.
    그런데 이 변수가 변경될 경우 컴포넌트의 변경이 자동적으로 이루어지지 않는다!
    이런 종류의 변수 업데이트가 가상돔과 실제돔에 바로 반영되도록 실시간 감시역할을 하는
    리액트의 기술내용을 담고 있는 것이 후크다!

1. 목적 : 어떤 특정 데이터가 변경될때
    이 데이터를 할당하여 사용하고 있는 컴포넌트의
    변경이 반영되도록 하고자 할때 후크를 사용한다!

2. 구현방법:
    1) 노드JS SPA 개발환경에서는 상단에 import useState를 한다!
    -> CDN 에서는 React.useState 로 사용함!
    2) 코딩법 : useState() 메서드사용
        배열변수 = useState(초기값)
        (CDN) -> 배열변수 = React.useState(초기값)

        ((일반형))
        const [변수명,set변수명] = useState(초기값)
        -> set변수명 작성시 변수명 첫글자는 대문자로 씀
        예) 변수명 myname -> setMyname
        -> set변수명(값) : 메서드형태로 후크변수의 값을 셋팅함!

    3) 작동원리 
        - useState에 쓴 초기값이 배열변수 첫번째변수에 할당된다!
        - 코드에서 set변수명에 값을 할당하면
        useState메서드가 이것을 체크하여 이 변수를 사용한
        다른부분의 업데이트를 실행한다!
        예컨데 컴포넌트 내부에 사용한 경우 컴포넌트가 업데이트 됨!
    4) 사용결과
        - 별도의 메서드 호출없이 후크 상태변수를 사용한 곳이
        자동으로 변경될대마다 다시 갱신되는 것을 확인 할 수 있다!

    -> 뷰JS의 리액티브 데이터와 매우 유사함!

[ 리액트 성능 최적화를 위한 문제 인식!! ]
    -> 하나의 버튼 클릭 시 하나만 변경 됨에도 불구하고 전체 컴포넌트가 리 렌더링 된다
    이때 호출되는 함수도 새로 만들어져서 호출됨!
    -> 이게 효율성과 최적화에 문제가 됨
    어떻게 기존에 만들어진 함수를 다시 로딩하지 않을 수 있을까?
    >>>>> 메모이제이션 활용 <<<<< : useCallback

    - 아래와 같이 의존성변수를 등록하여 변경 여부에 따라 함수를 기존에 로딩한 것으로 재사용!
    해주는 것이 useCallback이다

    const [의존성변수, set의존성변수] = useState(초기값);
    const 콜백 = useCallback(() => {}, 
    [의존성변수]);
    _______________________________________________________________________________
    **주의)호출되는 컴포넌트가 매번 리 랜더링 되므로 메인 컴포넌트에 useCallback처리된 함수도 매번 새로 그려진다
    그래서 효과가 없다. 따라서 호출되는 서브컴포넌트를 메모이제이션 처리 해주어야 useCallback도 효과가 있다.
**주의)호출되는 컴포넌트가 매번 리 랜더링 되므로 메인 컴포넌트에 useCallback처리된 함수도 매번 새로 그려진다
//     그래서 효과가 없다. 따라서 호출되는 서브컴포넌트를 메모이제이션 처리 해주어야 useCallback도 효과가 있다.
// ->>> 방법 : 기존 컴포넌트 함수를 memo처리 하기!

[ 리액트 라이프사이클(life cycle) ]


1️⃣ 리액트의 생명주기

컴포넌트는 
생성(mounting) -> 업데이트(updating) -> 제거(unmounting)
의 생명주기를 가진다.

리액트 함수형 컴포넌트는 Hook을 사용한다!
리액트 클래스 컴포넌트는 라이프 사이클 메서드를 사용한다!

🎨 1.1. 함수형 컴포넌트 생명주기 🎨
----------------------------------

리액트에서 Hook은 함수형 컴포넌트에서 React state와 
생명주기 기능을 연동 할 수 있게 해주는 함수이다.

Hook은 class 안에서는 동작하지 않고, class없이 React를 사용할 수 있게 한다.

__________________________________
🎃 리액트 훅(Hook)을 도입한 목적 🎃
----------------------------------

기존의 라이프사이클 메서드 기반이 아닌 로직 기반으로 나눌 수 있어서 
컴포넌트를 함수 단위로 잘게 쪼갤 수 있다는 장점이 있음!

라이프사이클 메서드에는 관련 없는 로직이 같은 메서드에 위치하게 되는데
이로인해 버그가 쉽게 발생하고, 무결성을 쉽게 망가지게 한다.

____________________________
🎃 Hook 사용 규칙 두가지 🎃
----------------------------

[1] 최상위 컴포넌트에서만 Hook을 호출한다.

[2] 반복문, 조건문, 중첩된 함수 내에서 Hook를 실행하지 않는다.
_________________________________________

이 규칙을 따르면 컴포넌트가 렌더링될 때마다 
항상 동일한 순서로 Hook이 호출되는 것이 보장된다.

리액트 함수 컴포넌트에서만 Hook을 호출해야 한다.
일반 JS함수에서는 Hook을 호출해서는 안된다.

_________________________
🎃 Hook의 종류와 정리 🎃
------------------------

☑️ useState
상태를 관리한다.
리액트 버츄얼돔의 컴포넌트에서 사용되는 변수
구성 요소에 상태 변수를 추가할 수 있는 React Hook
[state이름, setter이름] 순으로 반환 받아서 사용

const [변수, set변수] = useState(초기값);

-> set변수 (변수 첫글자 대문자)

☑️ useEffect
화면에 렌더링이 완료된 후에 실행됨!
구성 요소를 외부 시스템과 동기화할 수 있는 React Hook

componentDidMount와 componentDidUpdate, 
componentWillUnmount가 통합된 것!

🍓만약 화면을 다 그리기 이전에 동기화 되어야 하는 경우
(화면에 뿌려지기전에 틀만 뿌려지고 기본상태를 만들기 위해서는 이걸 사용)
(useEffect는 뿌려지고 다시 없어지고 이펙트가 보여서 반짝하고 살짝 보여짐)
useLayoutEffect를 활용한다!!!

컴포넌트 렌더링 -> useLayoutEffect 실행 -> 화면 업데이트 
순으로 effect를 실행시킬 수 있다!

☑️ useEffect 옵션 정리 :

1. 렌더링 결과가 실제 돔에 반영된 후마다 호출
useEffect(() => {});

2. 컴포넌트가 처음 나타날때 한 번 호출
useEffect(() => {}, []);

3. 조건부 effect 발생, 의존성 중 하나가 변경된다면 effect는 항상 재생성
useEffect(() => {}, [의존성1, 의존성2, ..]);

4. useEffect안에서의 return은 정리 함수(clean-up)를 사용하기위해 쓰임!
메모리 누수 방지를 위해 UI에서 컴포넌트를 제거하기 전에 수행
컴포넌트가 여러 번 렌더링 된다면 다음 effect가 수행되기 전에 
이전 effect가 정리된다!
(코드) useEffect(()=>{
    랜더링 관련 코드...
    // return은 정리 함수(clean-up)
    return(()=>{
        컴포넌트 제거 시 발생하는 체크구역
    });
});
___________________________________________________________
🎃 ContextAPI 와 useContext 후크를 통한 전역상태값 관리 🎃
------------------------------------------------------------

🍓 Context API란?
전역 상태(global state) 값을 공유할 수 있도록 
React에서 고안된 방법
주로 로그인한 유저 정보, 테마, 언어 등을 저장한다.

Prop Drilling의 단점을 보완한다!

((Prop Drilling 이란?))

Prop Drilling은 컴포넌트 트리에서
컴포넌트에 직접적으로 필요한 데이터를 
props로 전달받는 것이 아니라,
단순히 컴포넌트 트리의 하위 컴포넌트로의 
props 전달을 위하여 데이터를 전달하는 과정임

🍓 Context API 사용법

☑️ [React.createContext(기본값)]
- Context 객체를 생성
createContext 함수를 호출하면 
Provider와 Consumer 컴포넌트를 반환함

파라미터로 넘겨받는 값은 
Provider를 사용하지 않았을 때 적용될 초기값

[Context.Provider]
context의 value를 변경하는 역할을 한다.
Provider 선언시 value props를 통해 
context의 value를 입력받음
이 속성값 value는 context를 통해 전역적으로 공유되는 값임!

[useContext 후크]
context의 value를 가져올 때 사용
파라미터로 넘겨받는 값은 
createContex를 통해 생성된 Context 객체임

(위의 useState / useEffect / useContext 는 기본 Hooks라고 부른다!)
참고:
https://ko.legacy.reactjs.org/docs/hooks-reference.html

☑️ React - 메모이제이션(Memoization) : 추가 Hooks

🍓 React에서 메모이제이션을 하는 방법

[1. useMemo]
[2. React.memo]
[3. useCallback]

🍓 메모이제이션(Memoization)
메모이제이션은 컴퓨터가 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로서 
중복계산을 피하여 데이터 속도를 높이는 기술. 보통 애플리케이션의 최적화를 위해 사용

1. useMemo -----------------------------------
- useMemo재렌더링 간 계산 결과를 캐시할 수 있는 React Hoo
useMemo를 사용하면 함수 컴포넌트 내부에서 발생하는 
연산을 최적화할 수 있음. 이전 값을 기억해두었다고 
조건에 따라 재활용하여 성능을 최적화 하는 용도로 사용
메모이제이션된 값을 return하는 후크다!
+++++++++++++++++++++++++++++++++++++++++++++++++
const 변수 = useMemo(() => {}, [관리변수]);
+++++++++++++++++++++++++++++++++++++++++++++++++
관리변수 값이 변경되면 메모이제이션의 함수를 재실행함.
만약 인자를 전달하지 않는다면 매번 새롭게 계산하여 return함
___________________________________________________________

2. React.memo ------------------------------------
함수 컴포넌트에서는 일반적으로 라이프 사이클을 사용할 수 없음 
그래서 React.memo라는 함수를 사용함. 
컴포넌트의 props의 전달값이 변경돼야만 랜더링변경함
설정하여 함수 컴포넌트의 리렌더링 성능을 최적화함
(주의: 함수를 전달할 경우 매번 새로운값으로 인식함!)
+++++++++++++++++++++++++++++++++++++++++++++++
const Component = React.memo((props) => {
   return (컴포넌트 랜더링 코드)}
);
++++++++++++++++++++++++++++++++++++++++++++++++
이전과 같은 props 값이 들어올 때는 렌더링 과정을 스킵
가장 최근에 렌더링된 결과를 재사용함 -> 이것이 메모이제이션임! 재사용!!!
단, 컴포넌트 내부에서 useState 훜 사용시 상태가 변경 되면 리렌더링됨
_______________________________________________________________

3. useCallback -------------------------------------
- useCallback재렌더링 사이에 함수 정의를 캐시할 수 있는 React Hook
useCallback을 사용하면 만들어 놨던 함수를 재사용할 수 있음
컴포넌트가 렌더링 될 때마다 내부적으로 사용된 함수가 새롭게 
생성되는 경우, 이미 사용된 같은 함수를 메모이제이션 하여 재사용함!
++++++++++++++++++++++++++++++++++++++++++++++++++++++
const [의존성변수, set의존성변수] = useState(초기값);
const 콜백 = useCallback(() => {}, 
[의존성변수]);
+++++++++++++++++++++++++++++++++++++++++++++++++++++++

(주의: 콜백을 호출하는 코드가 재사용되는 메모이제이션처리 돼야 
콜백 호출이 부분 업데이트가 된다! 즉, 재사용되는 메모이제이션 처리된다!)

☑️ useRef
1. 특정 DOM 선택할때 주로 쓰이며 .current 프로퍼티로 전달된 인자로 
초기화된 변경 가능한 ref 객체를 반환한다. 
-> 예) <참조할요소/컴포넌트 ref='useRef사용변수명" .../>
-> ref속성의 값으로 설정 된 useRef변수를 써준다. 이 변수에 담긴 요소를 사용 할 수 있다.
-> 사용법) 변수명.current = 할당값;

2. 그밖에 컴포넌트가 리랜더링 되어도 변경 되어서는 안되는 
변수의 값이 있다면 useRef를 사용하여 일정값을 유지함!

반환된 객체는 컴포넌트의 전 생애주기를 통해 유지된다.

const myRef = useRef(null);

[ 02.리액트 컴포넌트에서 데이터전달하기 ]
->>> 프롭스 다운! 프롭스 펑션 업 다운!!

- 일반적으로 리액트에서 데이터는 하위 컴포넌트로 props를 통하여 전달한다! 

-> 일반적인 함수는 바깥쪽에 선언하면 전역변수, 함수내부는 지역변수로 사용했으나 
컴포넌트는 자식 컴포넌트가 부모컴포넌트의 변수,함수 등을 직접 호출할 수 없다!

_____________________________________________________

🙂1. 부모 컴포넌트 -> 자식 컴포넌트로 값전달🙂

->>> Props Down!!! -> 속성을 통하여 값을 전달한다!!!
<컴포넌트명 속성명=값 />
_____________________________________________________

🤔2. 자식 컴포넌트 -> 부모 컴포넌트 값전달(함수호출!)🤔

->>> Props Function Up & Down -> 함수를 내려보내고 호출받음!
<컴포넌트명 속성명={부모함수명} />
-> 자식컴포넌트에서 속성으로 보낸 부모함수를 호출할 수 있다!
이때 부모함수가 값을 받게하면 값도 전달된다!!!
_____________________________________________________

😌3. 형제 컴포넌트는 서로 값을 어떻게 전달하나?😌
자식-> 부모 -> 다른자식

[ 부분 리액트 적용하기 ]
1. 페이지 중 리액트 구성이 필요한 경우 CDN으로 별도 구성하여 적용 할 수 있다.

2. 리액트 구성페이지 필수체크요소
(1) 컴포넌트구성 대상 선정
- 기준 : 대상컨텐츠에 관여하고 있는 여부(질문:데이터 업데이트의 영향을 주는가?)
- 대상 : 아이템페이지 이동 메뉴와 컨텐츠 박스

(2) 컴포넌트 구성 방법
- 기존에 HTML 코드로 바로 구성된 부분을 모두 컴포넌트화 하여 리액트가 관리하게 한다.
- 분리작업 : 데이터와 태그 구성을 분리한다.
- 기존 html요소 데이터를 배열 객체 데이터화 함

(3) 리액트 적용 페이지 키구성
- 상태관리변수를 지정하고 이에 따른 데이터 변경연결
- 상태관리 변수 대상: 핵심 데이터의 키(속성명)

(4) 리액트 적용 페이지 이벤트 메서드 구성
- 리액트 이벤트 대상에 이벤트를 설정 후 적절한 메서드에 연결하여 구성한다.

(5) 리액트 적용 순서
    1) 본 페이지의 컴포넌트 대상 요소를 삭제
    2) 리액트 라이브러리 삽입
    3) 컴포넌트 구성하여 페이지에 렌더링
    4) 데이터 변경 키를 선정하여 상태변수로 등록
    5) 이벤트 설정 컴포넌트에 상태변수 변경 메서드를 생성하여 연결한다.
    6) 전체 렌더링을 확인하여 컴포넌트 생성 순서 혹은 이벤트 호출 순서를 구성한다.

[ 속성값을 읽어오는 메서드 2가지 ]
  - attribute 의 메서드 : attr(속성명), getAttribute(속성명)
  - property 의 메서드 : prop(속성명)
  -> 둘의 차이는 속성값을 읽을 때는 차이가 없음
  ->> 체크박스에서 checked속성 인 경우 true/false를
      리턴해주는 것은 prop()메서드 뿐이다.
  [ 속성 값을 세팅하는 메서드 2가지 ] : 오버라이딩 됨
  1. attr(속성명, 값), setAttribute(속성명, 값)
  2. prop(속성명, 값)
  _____________________________________
  attr() - HTML attribute 값이 모두 String 으로 넘어옴 
  prop() - 자바스크립트의 프로퍼티 값이 넘어오기 때문에 boolean, date, function 등도 가져올 수 있음
  .prop()는 .attr() 보다 약 2.5 배 빠름
[ 사용자 입력 폼 유효성 검사 ]
    - 이벤트 종류 : blur(<->focus)
    - 제이쿼리 이벤트 메서드 : blur()
    - 이벤트 대상: 입력요소 중 text(이메일뒷주소제외),password
        form.logF input[type=text][id!=email2],
        form.logF input[type=password],
    - 요소 뒤 대괄호는 속성선택자(CSS문법)
    - [id!=속성명] 은 같지 않다(jquery문법)
const groSpace = (x) => x.replace(/\s/g, "");
  // replace(정규식, 바꿀문자)
키보드 입력 시 이메일 체크하기
  ___________________________
  
  - 키보드 관련 이벤트 : keypress,keyup,keydown
  1. keypress : 키가 눌려졌을 때
  2. keyup : 키가 눌려졌다가 올라올 때
  3. keydown : 키가 눌려져서 내려가 있을 때
  -> 글자가 입력 되는 순간은 어떤 이벤트를 사용 해야 할까
  ->> keyup
  ->>> 나머지는 값이 입력되기 전에 전달되어 값이 정확하게 전달되지 않음

  - 이벤트 대상 : eml1 eml2
  -> 모든 이벤트 함수와 연결하는 제이쿼리 메서드는?
  on(이벤트명 , 함수)
가입하기(submit) 버튼 클릭 시 처리하기
    __________________________________
    
    - form요소 내부의 submit버튼을 클릭하면 기본적으로
    form요소에 설정 된 action속성값인 페이지로 전송된다!
    전체검사를 위해 이를 중지해야한다.
    -> 중지방법은 event.preventDefault()!!!!
    
    전체검사의 원리 :
    전역변수 pass를 설정하여 true를 할당하고
    검사중간에 통과실패 사유발생 시 false로 변경
    유효성검사 통과여부를 해당 전역변수로 판단한다.

    검사방법 :
    기존 이벤트 blur 이벤트를 강제로 발생시킨다!
    이벤트를 강제로 발생시키는 제이쿼리 메서드는?
    ->>> trigger(이벤트명)