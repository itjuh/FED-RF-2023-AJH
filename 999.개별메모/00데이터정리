[ 배열데이터를 변경하여 다시 배열로 만들기 : map()] : 9/14
    
  배열변수.map((배열값,순번,전체배열)=>{변경코드})
  -> 결과로 변경 된 배열이 리턴 됨

  ex) const arr = ['두현','대희','민희'];
  let arr2 = aa.map(val => val+'씨');
  -> 결과: ['두현씨','대희씨','민희씨'];
  ____________________________________________
  Array.isArray(배열); 
  -> 결과로 true / false가 리턴됨
  ____________________________________________
  -> 새로 만들어진 배열 데이터를 현재 자리에 그대로 출력할 때
  배열메서드 .join(구분자)를 이용하여 배열을 하나의 문자형
  데이터로 만들어 주면 편리하다.
  ex) const aa = ['하하','호호'];
  `<div>${aa.map(val => `<h2>${val}</h2>`).join('')}</div>`
  -> 결과: <div><h2>하하</h2><h2>호호</h2></div>
  -> 구분자가 없는 태그로만 구성 된 최종데이터를 그 자리에 출력 함
  ->>>>잊지말자 맵 조인

[ 배열값 사이에 결합값 넣어서 출력하기 : arr.join(''); ] : 9/14
배열값 출력할 때 배열.join('') 쓰면 연결값이 ''안의 값으로 들어감


[ 젠코딩 ] : 9/14
ul>li>a[href='#']{1차}+.smenu>aside.smbx>h2>(.stit{1차}+a[href='#']{전체보기})+.swrap>dl>dt{2차}+dd>a[href='#']{3차}

-> 결과: <ul>
            <li>
                <a href="#">1차</a>
                <div class="smenu">
                    <aside class="smbx">
                        <h2>
                            <div class="stit">1차</div>
                            <a href="#">전체보기</a>
                            <div class="swrap">
                                <dl>
                                    <dt>2차</dt>
                                    <dd><a href="#">3차</a></dd>
                                </dl>
                            </div>
                        </h2>
                    </aside>
                </div>
            </li>
        </ul>


[[ JavaScript에서 요소의 위치 구하기]]

[ offsetTop / offsetLeft] 
-> 부모자격요소를 기준한 위치값
-> 제이쿼리 position()과 같음

[ getBoundingClientRect() > top / left ] 
-> 스크롤위치를 뺀 화면 기준
-> 제이쿼리의 offset() 과 같은 절대값을 구하려면
스크롤위치값을 본 값에 더해야함!
-> 주로 세로 스크롤을 사용하므로 top값에 스크롤값을 더함
예) 요소.getBoundingClientRect().top + window.scrollY

※ 참고: 바운딩 값은 소수점 아래 많은 자릿수까지 표시하므로
    이것을 소수점자리 제한하여 사용할 수 있다!
    -> toFiexd(자릿수) : 자릿수에 0을 넣으면 소수점 아래버림

    [[ JavaScript에서 요소의 크기 구하기 ]]★

-> 한눈에 보기:
http://jsfiddle.net/y8Y32/25/

[ 가로크기 ]
- clientWidth : 패딩점퍼를 입고 있는 클라이언트님!
    padding을 포함한 폭
- scrollWidth :  가로스크롤내용이 들어가니까 scroll!
    padding을 포함한 화면 상에 표시되지 않은 콘텐츠를 포함한 폭
- offsetWidth : 보더,패딩,세로스크롤바 트랙이 다 들어가니 옵셋!
    border, padding, 세로스크롤바 트랙을 포함한 폭

[ 세로크기 ]
- clientHeight : 패딩점퍼를 입고 있는 클라이언트님!
    padding을 포함한 높이
- scrollHeight :  세로스크롤내용이 들어가니까 scroll!
    padding을 포함한 화면 상에 표시되지 않은 콘텐츠를 포함한 높이
- offsetHeight : 보더,패딩,가로스크롤바 트랙이 다 들어가니 옵셋!
    border, padding, 가로스크롤바 트랙을 포함한 높이

[[ 윈도우 사이즈 가져오기 ]]
window.innerWidth :  스크롤 바를 포함하지 않는 창 너비
window.innerHeight : 스크롤 바를 포함하지 않은 창 높이
window.outerWidth : 스크롤 바를 포함, 창의 너비
window.outerHeight :  스크롤 바를 포함한  창의 높이

[[ 현재 스크롤바 위치값 가져오기 ]]
1. window.scrollY (IE6~11지원안함)
2. document.scrollingElement.scrollTop
3. document.documentElement.scrollTop
4. document.querySelector('html').scrollTop

_____________________________________________________________

[[ 이벤트발생시 위치값 ]]
1. clientX, clientY
    -> 현재 보이는 브라우저 화면이 기준

2. offsetX, offsetY
    -> 이벤트 대상이 기준

3. pageX, pageY
    -> 전체 문서를 기준(스크롤 화면을 포함)

4. screenX, screenY
    -> 모니터 화면을 기준
_____________________________________________________________

[ 가로방향 이동 ]
ul의 부모박스는 세로스크롤 적용해야하니 100vh + 컨텐츠양만큼
컨텐츠ul 가로스크롤 해서 이동시키는건 100vw + 컨텐츠양만큼
li는 등분할
[ 메뉴에 오버 시 움직이는 배경 ]
js실험실 중간스크롤 가로이동

[ 1. 선형그라데이션 ] 9/18_nav07

1) 균등분할 그라데이션
background-image: 
    linear-gradient(방향, 색1,색2,색3,...);
- 방향: to top, to bottom, to right, to left

2) 사용자 지정영역 그라데이션
background-image: 
    linear-gradient(방향, 색1 몇%,색2 몇%,색3 몇%,...);
- 색상 뒤에 한칸 띄어 %수치를 주면 색상영역조정됨

3) 각도 지정 그라데이션
background-image: 
    linear-gradient(각도, 색1,색2,색3,...);
- 각도: 각도수치deg

_____________________________________________

[ 2. 원형 그라데이션 ] 9/18_nav07

- 기본형, 영역지정형은 박스모양을 따라감!

1) 기본형: 중앙중심, 모양은 박스크기에 맞춤
background-image: 
    radial-gradient(색1,색2,색3,...);
- 시작색으로부터 중앙에서 시작됨

2) 영역 지정형:
background-image: 
    radial-gradient(색1 몇%,색2 몇%,색3 몇%,...);
- 색 뒤에 한칸 띄고 %수치로 영역지정함

3) 그라데이션 모양을 원형으로 사용할 경우:
background-image: 
    radial-gradient(circle,색1,색2,색3,...);
- circle 키워드를 첫번째에 사용함

4) 영역옵션 지정형: 중심점 변경
background-image: 
    radial-gradient(옵션 at 가로위치 세로위치,색1,색2,색3,...);
- 옵션4가지 : closest-side / farthest-side
            closest-corner / farthest-corner
            ___________________________________
            - closest는 중심점으로 좀더 모아진것
            - farthest는 중심점에서 멀리 퍼진것
            - side와 corner는 경계선과 끝부분옵션임
- 가로위치, 세로위치 (중심점) - 단위는 px / %

[ video 요소 - html5에서 지원하는 비디오 재생요소 ]

-> img 태그와 비슷하게 쉽게 비디오를 삽입하도록 등장!

((속성들))
1. src : 파일경로
2. controls : 동영상 제어버튼바
    (이게 있으면 화면클릭으로 또는 스페이스바로 재생/멈춤 가능)
3. autoplay : 자동재생(소리없음에서 작동)
4. muted : 소리없음
5. loop : 무한반복재생
6. playsinline : 모바일 ios (아이폰) 동영상 재생시 자동재생 및 동영상이 페이지에 삽입된 상태에서 재생되도록 설정하는 옵션
(안드로이드는 없어도 자동재생 및 삽입재생됨!) 
7. poster : 비디오가 멈춤상태일때 첫화면 이미지
    (값으로 이미지 경로만 쓰면 됨) 
_____________________________________________

[ video 요소의 다른 표현법 ]
- video 하위 source 요소를 사용한 표현법
-> 이런 형식을 쓰는 이유는 같은 비디오가 브라우저에서
지원되는 비디오 형식을 맞추는데 그 목적이 있다!
-> 모든 비디오 형식을 지원하지 않을 경우
source요소 맨 하단의 쓴 글자가 화면에 출력된다!

예시코드)

<video autoplay muted loop>
    <source src="images/cgv.mp4" type="video/mp4">
    <source src="images/cgv.ogg" type="video/ogg">
    <source src="images/cgv.webm" type="video/webm">
    당신의 브라우저는 본 비디오를 재생할 수 없습니다!
</video>
_________________________________________________

[ 비디오 압축형식 ]
1. mp4 - 최신 브라우저에서 지원하는 가장 보편적인
    비디오 압축형식(오디오 전용은 mp3)        
2. ogg - 오픈 표준파일 형식 Xiph.org 재단에서 개발
3. webm - 개방형 미디어 컨테이너. 높은 비디오 재생품질

-> mkv, mov, avi 등과 같이 기존에 사용하던 일반
압축형식은 브라우저에서 지원하지 않는 경우가 많다.
따라서 비디오를 mp4형식으로 변환하여 올리게 좋다!
(유튜브 동영상은 모두 mp4로 변환하여 서비스중이다!)

************모듈화*********************

[ export 형식 ] 9/19 js모듈

1. export default 변수;
-> 단일한 변수(함수)를 내보낼 때 사용
-> default 키워드 : 
    단 하나의 변수만 내보내는 형식을 제한!
    1) 받는 곳(import)에서 받을 때 변수명을
    마음대로 사용 가능함
    2) 보내는 곳도 변수 없이 내보낼 수 있음
2. export {변수, 변수, 변수};
-> 여러개의 변수(함수)를 내보낼 때 사용

[ import 형식 ] 9/19 js모듈

import 전달변수 from 파일경로;
-> 반드시 가져올 모듈JS에서 export를 해줘야함!
-> from 뒤에 경로는 반드시 상대경로일 경우
같은 위치일 지라도 ./ 표시를 꼭해야함!(없으면 안나옴!)
(/,./,../ 표시필수)
-> 모듈구성은 반드시 서버형식으로 열어야 작동한다!
(http://...) Live Server로 열기때문에 볼 수 있음!
-> 로컬파일로 열면 작동안됨!
-> from뒤에 파일명 확장자 꼭 써야함
-> SPA 모듈 개별환경에서는 .js, .jsx 등 확장자 생략 가능

[ import 시 변수명 변경하기 : 별칭사용하기 ]
import {전달변수 as 별칭} from 파일경로;
예) import {mymymy as m} from 파일경로;
-> 별칭 사용이유:  단순변경요구, 같은이름 변수 피하기
-> 별칭 변경 후 꼭 별칭으로만 불러야함
____________________________________________________

[ 모듈화를 위한 구성 ] 9/19 js모듈
1. 데이터 처리하기 위한 JS
-> text_data.js
2. 구체적인 데이터 구성처리를 위한 JS
-> msgFormat.js

[ 패럴렉스 위치 계산 ]

1. 전체범위 : window.innerHeight
2. 위치값 : getBoundingClientRect().top
3. 정한범위 : 이동 할 수치 
4. 실제이동값 : transform:translateY(이동수치px);
______________________________________________

((비례식으로 실제 이동값 알아내기))

전체범위 : 위치값 = 정한범위 : 실제이동값
실제 이동값 = 위치값*정한범위 / 전체범위

-> 그.런.데...
Y축 위치 이동은 처음에 0부터 서서히 커지므로
이동수치값은 정한범위에서 실제 이동값을 빼야함

실제 이동값 = 정한범위 - (위치값*정한범위 / 전체범위);

[ 패럴렉스 기본값 세팅 ]
// 0-1. 새로고치면 스크롤바 위치 캐싱 후 맨 위로 이동
setTimeout(() => {
    // 윈도우 스크롤 맨 위로!
    window.scrollTo(0,0);
    // 부드러운 스크롤 위치값 반영!(전 위치로 이동해버림)
    setPos(0);
    // 안하면 스크롤 바를 내리고 새로고침하면 원래 위치로 강제이동함
}, 500);
// 0-2. 스크롤바 트랙을 잡고 위치 이동 시 위치값 반영
domFn.addEvt(window,'mouseup',()=>setPos(window.scrollY));
// 0-3. 키보드 방향키 이동 시 위치값 반영
domFn.addEvt(window,'keyup',()=>setPos(window.scrollY));

/*
getBCR는 스크롤 내릴수록 작아짐 (요소가 움직이 범위에 대한 변수)
getBCR는 숫자 작아짐 (화면높이부터~0으로)
화면이동값 translateY(-스크롤Y(0부터 화면높이로 커짐));
두 값의 비례식을 위해서 값의 조정이 필요함

전체범위 : 위치값 = 정한범위 : (정한범위 - 실제이동값)
*/

[ 슬라이드 만들기 ]
1-1. 오른쪽버튼 클릭 시 - 맨앞 div 맨 뒤로 이동
-> 부모박스.appendChild(domFn.qsaEl(부모,자식)[0]);
1-2. 왼쪽버튼 클릭 시 - 맨 뒤 div 맨 앞으로 이동
-> 부모박스.insertBefore(자식[자식.length - 1],자식[0]);

_________________________________________________

[ 문자치환함수 ] 9/21
 replace(바뀔값,바꿀값)
- 특정문자를 다른문자로 변경해주는 JS내장함수
-> 바뀔값이 여러개이면 정규표현식을 쓴다!

[ 문자추출함수 ]

1) substr(시작순서,개수)
-> 대상문자열에서 시작순서를 0부터셈,
    개수는 시작순서부터 몇개의 문자인지 씀

2) substring(시작순서,끝순서) (시작순서,시작순서+개수);
-> 대상문자열에서 시작순서를 0부터셈
    끝순서는 0부터 세서 보이고자하는 문자뒷문자번호를 씀

3) 공통사항 : substr(시작순서) / substring(시작순서)
-> 시작순서만 쓰면 시작순번부터 끝까지 문자열을 가져온다!

[ 문자 자르기 함수 ]
split(자를기준문자열)
-> 문자열을 기준문자로 split하여 자르면 배열이 된다!
let arr = string1.split(' ');
console.log(arr[0]);

[ 숫자데이터 문자형가공 ]
String(숫자데이터)
-> 숫자형 데이터를 문자형으로 변환
let res2 = String(str1) + String(str2); 
// 문자+문자=문자

[ 문자데이터 숫자가공 ]
Number(문자데이터)

[ 정규표현식 ] 9/21
정규 표현식(正規表現式, 영어: regular expression, 
간단히 regexp 또는 regex, rational expression)
또는 정규식(正規式)은 특정한 규칙을 가진 문자열의 집합을
표현하는 데 사용하는 형식 언어이다.

예) 이메일형식, 전화번호형식, 아이디구성형식, 비밀번호형식

[ 간단한 정규식 표현기호 ]

1. 정규식 내용은 따옴표를 쓰지 않고 슬래쉬를 사용함

2. 모든 패턴문자열을 찾을때 g라는 플래그문자를 사용함

    g는 global 에서 온말 즉, "전역"이라는 의미
    - i 플래그문자는 대소문자 구분안함 표시자

예) /,/g -> 모든 콤마문자를 찾아라
    /s/gi -> 모든 s문자를 대소문자 구분없이 찾아라

-> 참고 사이트:
https://www.w3schools.com/jsref/jsref_obj_regexp.asp

[ 투명색 ]
background-color: transparent;

[ 데이터 sort / 오름차순 데이터를 내림차순하여 화면에 뿌리기 ] 9/21 4교시
let preNewData = previewData.sort((x,y)=>{
  //x,y는 배열값 앞 뒤를 계속 가지고 들어옴
  //배열값 중 idx속성값을 가져와서 숫자형변환 후 사용
  let a = Number(x.idx);
  let b = Number(y.idx);

  // 배열 순서 변경 메서드인 sort() 내부에 return값을 
  // 사용하여 순서를 변경 한 새로운 배열을 만들어 준다.
  return a == b ? 0 : a > b ? -1:1;
  // if(a==b) 0 else{if(a>b) -1 else 1}
});
console.log(preNewData);

[ 제이슨파일 불러오기 ]
import langCode from './data_lang.json' assert{type:'json'};
제이슨 import 맨 뒤에 assert(주장하다! 제이슨임을 주장해준다)
assert{type:'json'}; => 어서써 타입 제이슨!
원래 제이슨파일과 같은 데이터 파일을 불러올 때는 데이터 파일을
다 불러온 후에 그 데이터를 이용하는 코드가 실행될 수 있도록 하는
비동기 코딩 방식인 Promise를 사용하는 것이 원칙이다.

_____________________________________________________________

[ 구조화방식의 변수할당 ]
새로운 구조화방식
    const home = ['의자','TV','노트북'];
변수를 한번에 선언하여 배열값을 각각 할당
    let [chair,tv,notebook] = home;
    console.log('구조화 방식으로 배열변수 할당:',chair,tv,notebook);

[ 스프레드 연산자 ]
객체 또는 배열 합치기
... (점3개로 표시 -> 배열/객체값 순서표시)
const addNumber2 = [...number1,...number2];
const myNewCars = {...car,...newCar};

[ this 키워드란 무엇인가? ] 9/25 js학습5-4

JavaScript에서 this키워드는 객체 를 나타낸다
어떤this 객체가 호출 되는지에 따라 달라진다
this키워드는 사용 방법에 따라 다른 객체를 참조한다
___________________________________________

1. 객체 메서드에서 객체자신을 의미
    - 단, 화살표함수는 전역객체(window)를 의미
2. 단독으로 전역객체(window)를 의미
3. 함수에서 전역객체(window)를 의미
4. 함수에서 엄격모드(use strict)일 경우 undefined
5. 이벤트에서 이벤트를 수신한 요소자신을 의미
6. 이벤트에서 화살표함수는 상위 이벤트요소를 의미
    (단, 상위 이벤트요소의 함수는 화살표함수가 아님!)

_______________객체와 배열__________________

[ 데이터 순회 ]

배열, 유사배열 forEach for_of(제어문)
객체 for_in(제어문)

[ 배열데이터 변경 메서드 ]

1. push(값) - 뒷배열추가!
2. pop() - 뒷배열삭제!
3. unshift(값) - 앞배열추가!
4. shift() - 앞배열삭제!
5. splice(순번,0,값) - 중간배열삽입!
6. splice(순번,개수) - 중간배열삭제!
_________________________________

7. join(구분자) - 배열값 구분자로 문자열변환!
8. map(v=>`<새값>${v}</새값>`) - 새배열!(배열리턴)
9. forEach(v=>{}) - 배열/유사배열 순회!
10. Object.keys(객체) - 객체의 키로 배열변환!

[ 객체의 속성(키 값)을 배열 변환 ]
객체형식 -> {키:값}
객체의 키를 배열로 변환하는 Object 객체 메서드: key()

1. 객체의 키를 배열로 : Object.key(객체);
2. 객체의 값을 배열로 : Object.key(객체).map(v=>객체[v]);

static object : Object, Array, Math, String, Number
처음에 생성할 때 new 키워드가 필요없음

[ 대상 포커스와 블러 ]
초점 가게하는 메서드 -> 대상.focus();
초점 빠지게 하는 메서지 -> 대상.blur();

[ 이벤트에 값 보내기 ]
evtBox.forEach((ele,idx)=>dFn.addEvt(ele,'mouseenter',()=>seeMe(idx)));
함수구역에 함수명만 쓰는게 아니고 순번을 전달
()=>seeMe(idx) :실행하지 않고 값을 보내는 함수를 화살표 함수로 할당함
function seeMe(idx){
    console.log('함수호출됨',idx,event.currentTarget);
    // 이때 this는 event.currentTarget으로 구할 수 있음
} 

[ 마우스 오버/아웃 관련 이벤트 차이점 ]

1. mouseover / mouseout : 요소 자체를 기준
2. mouseenter / mouseleave : 요소 경계선을 기준
-> 둘의 차이는 이벤트 버블링에 있다.
-> 경계선 기준의 이벤트인 mouseenter / mouseleave는
자체요소에서만 발생하고 버블링 되지 않는다.
-> 자손요소에서 버블링되어 발생하는 mouseover/mouseout으로
 셋팅 할 경우 빈번한 이벤트 발생이 문제가 될 수 있음
이때는 mouseenter / mouseleave를 사용 할 것을 w3c가 권고함!

[ 커서 이미지로 보이기 ]

cursor: url(이미지경로) x위치 y위치,auto 
-> 사이즈등의 이슈로 안나올 수 있으므로 auto/pointer등 대체항복을 뒤에 콤마하고 써야함
-> 이미지 커서의 위치는 맨위 왼쪽 끝이다.
-> 위치변경 옵션 x, y 위치는 단위없으면 자동 px, 이미지 크기보다 크면 처리안됨

[ sort() 메서드 ] : 오름차순, 내림차순은 리턴을 반대로 쓰면 됨 
sort() 메서드 내부에 2개의 전달값을 가지는 함수를 쓰면 sort메서드 자체에서 값을 비교하여 배열값의 순서를 바꾼다!

숫자데이터배열.sort((a,b)=>a-b)
숫자데이터배열.sort((a,b)=>b-a)
배열변수.sort((a,b)=>a==b?0:a>b?1:-1);
a:뒤의 값, b:앞의 값
1,양수: 순서 안 바꿈 -1,음수:바꿔 0:그대로

1. 문자형일 경우 대소문자가 섞여있으면 하나로 통일하여 비교해야함(toUpperCase()/toLowerCase())
예)
배열변수.sort((x,y)=>{
    let a = x.toUpperCase(),
        b = y.toUpperCase();
    return a == b ? 0 : a > b ? 1 : -1;
})

2. 날짜정렬도 숫자와 동일함(날짜데이터 자체가 숫자형으로 되어있음)

3. 특정언어의 특수문자일 경우 localeCompare() 메서드로 문자열 비교를 한다!
예) 특수문자 x변수를 y변수와 변환후 비교 
x.localeCompare(y)

[ select 옵션목록 - 초기값, 그룹, 옵션 ]
<option selected disabled hidden>선택하세요~</option>
//처음에 선택되어있고, 값이선택안되고, 목록에서 숨김
<optgroup label="대분류">
//선택되지 않음
    <option value="1">값1</option>
    <option value="2">값2</option>
    <option value="3">값3</option>
</optgroup>








[ 리액트란? ]

-> 프론트엔드 JS 라이브러리다!
-> 사용자 UI의 구성요소를 빌드하기 위한 도구
(빌드란? html구조와 언어에 데이터를 바인딩하여
배포하는 작업을 이름)

[ 작동원리 ]

-> 가상돔(Virtual DOM)을 사용하여 최소의 html리소스를 
사용하므로 빠르고 쉽게 UI 화면을 구성한다!
-> 가상돔은 실제 DOM을 변경하기 전에 
메모리상에서 구현하는 오브젝트 DOM이다.
-> 변경사항을 단위별로 한 번에 업데이트하기 위한 수단


[ 리액트 구현의 2가지 스타일 ]

# 스타일1 : 리액트는 JS 라이브러리이므로 필요한 부분에만 적용이 가능하다.
->라이브러리는 CDN방식으로 구현(별도의 설치가 필요 없다)

# 스타일2 : 리액트는 SPA(Single Page Application)이므로 
Node.js등을 사용하여 한 페이지로만 구현하는 웹을 만들 수 있다.
->Node.js, 리액트 SPA 개발환경 설정이 필요함!

[ 시작하기 리액트 JS ]

html 태그와 JS문법을 따옴표없이 사용하는 JSX문법을 사용한다!
JSX(Javascript XML) 문법을 쓰는 파일은 .js대신 .jsx확장자사용!
-> return 키워드 사용은 따옴표없이 바로 소괄호롤 묶어사용
(소괄호 생략 가능!)

[[ 주의사항 ]]
1. 함수를 만들경우 반드시 대문자로 시작해야 호출됨!(정해진규칙) :생성자함수(객체를 생성하기 위한 함수)
2. 홀로태그를 사용할때는 마지막에 스스로 닫기를 꼭 해줌!(/>)
3. 함수 내부의 리턴값으로 만든 요소는 반드시 최상위요소가 하나여여함!

[ 호출형태 ]
ReactDOM.render(요소를 리턴하는 함수명으로 된 홀로태그,대상요소)
__________________________________________

예컨데 함수명이 MyFirstReact이므로 
요소를 리턴하는 함수명으로 된 홀로태그는? <MyFirstReact />

그리고 대상요소는 JS문법으로 요소를 선택함!
document.querySelector("#root")


[ JSX 특성 ] 10/5 03.JSX
- Javascript XML을 나타냄
- 리액트에서 HTML을 쉽게 작성할 수 있다.
- appendChild() 메서드 없이 DOM에 요소넣기가 가능함!

[ 출력방식 정리! ] 10/5 03.JSX
1. 한꺼번에 쓰기
ReactDOM.render(출력할요소,대상요소)

2. 따로쓰기
    1) 생성변수 = ReactDOM.createRoot(대상요소)
    2) 생성변수.render(출력할요소)
______________________________________________

[ JSX 표현식 ] 10/5 03.JSX
JSX를 사용하면 중괄호에 표현식을 작성할 수 있다 : React변수, 속성, JS문법 등의 내용임
{........ 표현식 ........}

[ JSX 태그요소 작성시 여러줄일 경우 ] 10/5 03.JSX

1. 최상위를 하나 만들고 여러요소를 작성한다!
2. 소괄호로 전체를 싸준다!(소괄호생략가능!)

- 지원되는 스타일: SPA-전부, CDN-3),React.Fragment
1) <>태그들</>
2) <Fragment>태그들</Fragment>
3) <기존태그>태그들</기존태그>

-> 1),2)번은 CDN방식에서는 지원안함!(설치형SPA지원!)
-> 2)번 CDN에서 사용하려면 아래와 같이 사용한다!
    <React.Fragment></React.Fragment>
-> 1),2)번을 사용하는 이유는 쓸때 없는 태그삽입을 막는데있다!
-> 기존태그는 <div>,<section> 등 원래있는 html태그를 말함
    (단점, 원하는 않는 태그가 삽입됨!!!)









[ SVG란? ]
SVG - Scalable Vector Graphic
-> 이미지를 확대해도 깨지지 않는 벡터방식의 그래픽요소

[ svg 요소 표현법 - HTML ]
- svg요소 내부에 자식요소로 각 도형요소를 넣고 코딩 함 <svg><circle></circle></svg>
(유의사항: svg는 처음에 px단위의 특정크기로 만들어야한다. 
유동적인 크기는 viewBox설정으로 얼마든지 변경이 가능하다!!!)

1) circle 요소 : 원
<circle cx="150" cy="150" r="140" transform="rotate(-120,150,150)"/>
중심점 가로 150 세로 150위치 140반지름 원 회전(-120도 150중심점) 회전은 부모요소인svg에 transform이 적용가능
2) rect 요소 : 사각형
<rect class="rt1" width="280" height="280" x="10" y="10"/>
사각형 가로280 세로280 끝에서 가로10 세로 10만큼 떨어진 상태
3) polygon 요소 : 다각형
<polygon class="pg1" points="150,10 290,100 290,200 150,290 10,200 10,100"/>

[ SVG circle 설정 - CSS ]
1) 채우기 (fill:색상)
    기본값 : 검정 
    투명 : transparent - 안쪽이 안만져짐
    없음 : none - 원이 뚫려있는 효과
2) 선 색 (stroke:색상)
    기본값 : 없음
3) 선 두께 (stroke-width:숫자값)
    기본값 : 1px 
    단위를 안쓰면 px이 기본, 선 두께는 선의 중심선으로부터 생김
4) 데쉬선 속성 (stroke-dasharray: 숫자값)
    - 선,공백 순으로 데쉬 선 세팅함, 하나하나가 array배열임
    - 선 부터 전체 채우기 위해 일단 50%를 주고 선, 공백의 조각수를 계산하여 곱하기
    - 여기서는 50%를 주면 6조각이 나옴 50%*6 = 300%로 계산하면 채우기가 됨
5) 데쉬어레이 시작위치 밀기 (stroke-dashoffset: 숫자값)
    - 특정 숫자값을 주면 px만큼 밀어준다.
    - 계산 된 stroke-dasharray 선 채우기 값으로 밀어주면 공백부터 시작
6) 선 끝면처리 (stroke-linecap :옵션)
    1) butt : 끝에 중심선이 보임(기본값)
    2) square : 끝에 사각형으로 덮음
    3) round : 끝에 둥근모양으로 덮음

[ svg 라인 애니메이션 원리 - CSS ]
- 데쉬설정을 공백부터 시작하여 stroke-dashoffset 값을 0으로 변경할 때 
애니메이션 설정으로 하면 선이 그려지는 효과의 애니메이션이 완성된다!